<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-TW" lang="zh-TW">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="Author" content="VBird, 鳥哥" />
	<meta name="Description" content="" />
    <link href="../styles/default.css" rel="stylesheet" type="text/css" />
	<title>鳥哥的 Linux 私房菜 -- 遠端連線伺服器 Telnet/SSH/XDMCP/VNC/RSH</title>
    
</head>
<body style="margin:0; padding:0">

<center>


<!-- 這裡是關於頁首按鈕處的按鈕程式 -->
<div style="text-align:center">
<span style="font-weight:bolder; color:#3333FF"><span class="text_head0">鳥哥的<span class="text_head_en"> 
	Linux </span>私房菜</span></span><br />
<span style="color:#000080">為取得較佳瀏覽結果，請愛用 <a href="http://moztw.org" target="_blank">firefox</a>
	瀏覽本網頁</span><br />

<a href="http://linux.vbird.org" target="_top">鳥哥的 Linux 私房菜館</a> | 
<a href="../index.htm">目錄</a> | 
<a href="../linux_basic/index.htm">Linux 基礎文件</a> | 
<a href="../linux_server/index.htm">Linux 架站文件</a> | 
<a href="../linux_enterprise/index.htm">Linux 企業運用</a> | 
<a href="../linux_security/index.htm">安全管理</a> | 
<a href="http://phorum.vbird.org">新手討論</a> | 

<br />
</div>


<table summary="本文內容的排版" style="background-color: #fff;" border="0" cellspacing="0" cellpadding="0" class="wrap">
<tr><td style="width:16px; height:16px; font-size:6px;">　</td>
    <td style="width:718px; height:16px; font-size:6px;">　</td>
    <td style="width:16px; height:16px; font-size:6px;">　</td></tr>
<tr><td style="width:16px; font-size:6px;">　</td>
  <td width="718">
  	

<!-- 本文的檔頭部分 -->
<div style="text-align:center">
    <a href="0310telnetssh.htm">
    <span class="text_head0">遠端連線伺服器<span class="text_head_en"> Telnet / SSH / VNC / XDMCP / RSH</span></span></a><br />
</div>
    <div style="text-align:left">
        <a href="0310telnetssh.htm?thisscreen=800x600">切換解析度為 800x600</a>
    </div>
    <div style="text-align:right">
        <span class="text_history">最近更新日期：2006/09/19</span>
    </div>

<!-- 本文的檔頭部分 -->
<table class="head1" summary="排版：文章檔頭的說明"><tr><td class="head1">
	一部連上 Internet 上面的您的個人主機，最重要的是什麼呢？
	大概就是如何讓您自己可以連線進入自己的主機，並且進行所謂的『遠端操控』了吧！
	也就是說，您可以在任何具有連上 Internet 的電腦中，以遠端連線軟體連上 Internet
	，並藉由您主機上面的遠端連線伺服器軟體提供的功能，直接登入您的主機來進行操控的工作！此時，您將發現
	Linux 有趣又好玩的地方囉！在早期的 Unix Like 機器當中，幾乎都提供 Telnet 這個遠端連線伺服器軟體，不過，
	Telnet 本身是以『明碼』來傳送您操作的資料，安全上面是值得來思考要不要開放吶！
	這個時候就有需要瞭解一下傳送過程中以加密動作來傳送資料封包的
	SSH 這個遠端連線伺服器軟體啦！
	另外，除了純文字介面登入主機來進行操控之外，在現在的 Linux distributions 當中，
	還可以利用 X 相關的服務來幫助我們以圖形介面登入喔！很棒吧！ ^_^
</td></tr></table><br />

<!-- 本文的連結區部分 -->
<div class=block1>
<span class="text_h1">
1. <a href="#before">本章的行前準備工作</a><br />
2. <a href="#remote_access">遠端連線伺服器</a><br />
	<span class=text_h2>
	　　2.1 <a href="#remote_access_what">什麼是遠端連線伺服器</a><br />
	　　2.2 <a href="#remote_access_work">有哪些可供登入的類型？</a><br />
	</span>
3. <a href="#telnet">Telnet 伺服器</a><br />
	<span class=text_h2>
	　　3.1 <a href="#telnet_start">安裝、啟動與關閉服務</a><br />
	　　3.2 <a href="#telnet_client">好用的連線軟體</a><br />
	　　3.3 <a href="#telnet_safe">iptables, TCP_Wrappers, 純建議</a><br />
	</span>
4. <a href="#ssh">SSH 伺服器</a><br />
	<span class=text_h2>
	　　4.1 <a href="#ssh_connect">連線加密技術簡介</a><br />
	　　4.2 <a href="#ssh_start">啟動 ssh 服務</a><br />
	　　4.3 <a href="#ssh_client">ssh 用戶端連線</a>：
		<a href="#ssh_client_ssh">ssh</a>, 
		<a href="#ssh_client_sftp">sftp</a>,
		<a href="#ssh_client_scp">scp</a>,
		<a href="#ssh_client_putty">putty 與 pietty</a>,
		<a href="#ssh_client_psftp">psftp</a>,
		<a href="#ssh_client_filezilla">filezilla</a><br />
	　　4.4 <a href="#ssh_sshdconfig">詳細設定 sshd 伺服器：</a><br />
	　　4.5 <a href="#ssh_nopasswd">製作不用密碼可立即登入的 ssh 用戶</a>： ssh-keygen<br />
	　　4.6 <a href="#ssh_secure">安全設定：</a><br />
	</span>
5. <a href="#xdmcp">Xdmcp 服務的啟用</a><br />
	<span class=text_h2>
	　　5.1 <a href="#xdmcp_theory">X Window 的 Server/Client 架構</a><br />
	　　5.2 <a href="#xdmcp_setup">設定 XDMCP</a><br />
	　　5.3 <a href="#xdmcp_client">用戶登入</a><br />
	　　5.4 <a href="#xdmcp_close">關閉 XDMCP</a><br />
	</span>
6. <a href="#vnc">VNC 伺服器</a><br />
7. <a href="#rsh">RSH 伺服器</a><br />
	<span class=text_h2>
	　　7.1 <a href="#rsh_server">RSH Server</a>：<a href="#hosts.equiv">/etc/hosts.equiv</a>, 
		<a href="#rhosts">~user/.rhosts</a><br />
	　　7.2 <a href="#rsh_client">RSH Client</a>：<a href="#rsh_cmd">rsh</a>,
		<a href="#rcp">rcp</a><br />
	</span>
8. <a href="#rsync">以 rsync 進行同步鏡相備份</a><br />
9. <a href="#review">重點回顧</a><br />
10. <a href="#FAQ">課後練習</a><br />
11.<a href="#reference">參考資源</a><br />
<span class=text_h2>
12.<a href="http://phorum.vbird.org/viewtopic.htm?p=114550"
	target="_blank">針對本文的建議：http://phorum.vbird.org/viewtopic.htm?p=114550</a><br />
</span>
</span>
</span>
</div>


<!-- 本文的正式部分 -->
<hr /><a NAME="before"></a><img src="/images/penguin-m.gif" alt="大標題的圖示" height="34" width="25" align="middle" /><span class="text_h1">本章的行前準備工作</span><br />
<div class=block1>
	在這個章節當中我們會使用用戶端的連線軟體連線到主機端來操作主機，所以你必須要瞭解到你的主機防火牆必須要開放，
	並且要取消 SELinux 才行！另外，登入時會分析到的 PAM 模組也需要進行瞭解吶！
	本章後半部會介紹 X Window 的遠端登入，所以你也必須對於 X Server/client 的架構有點瞭解才行。<br />
	<ul>
	<li>瞭解<a href="0110network_basic.htm">網路基礎</a>，尤其網路是雙向的；
	<li>認識<a href="0240network-secure-1.htm">網路安全</a>當中的取消 SELinux ，以及<a 
		href="0250simple_firewall.htm">防火牆</a>的基本概念；
	<li>瞭解<a href="../linux_basic/0410accountmanager.htm">使用者與帳號</a>的相關概念；
	<li>認識 <a href="../linux_basic/0590xwindow.htm">X Window System</a>；
	<li>由於很多遠端連線伺服器軟體系統預設並不安裝，因此你必須要瞭解 <a href="../linux_basic/0520rpm_and_srpm.htm">RPM</a> 
		及 <a href="0220upgrade.htm">yum</a> 的使用。
	</ul>
</div>

<hr /><a NAME="remote_access"></a><img src="/images/penguin-m.gif" alt="大標題的圖示" height="34" width="25" align="middle" /><span class="text_h1">遠端連線伺服器</span><br />
<div class=block1>
	遠端連線伺服器對我們來說，可是一項很有用的工具啊！他可以讓我們更方便的管理主機。
	不過，方便是方便，安全性其實不很好的～所以，才要特別強調一下這個玩意兒啊！<br /><br />

	<hr /><a name="remote_access_what"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class=text_h2>什麼是遠端連線伺服器
	</span><br />
	<div class=block2>
		首先，我們要先來瞭解一下，什麼是『<span class=text_import2>遠端連線伺服器</span>』？
		這個東西的功能為何？我想，您應該已經聽過，一個良好的網路環境當中，一部開放到
		Internet 上面的伺服器，基本上，他可以不需要螢幕、鍵盤、滑鼠等等的配備，
		只要有基本的主機板、CPU、RAM、硬碟再加上一塊好一點的網路卡，並且連上
		Internet ！哈哈！那麼您要操控這部主機的時候，只要透過網路連線進來，然後進行任何修改即可！
		嘿！所以囉，這個時候主機自然不需要周邊設備啦！<br /><br />

		以鳥哥個人為例，目前鳥哥管理大約七、八部左右的 Unix-Like 主機，
		這些主機都不在同一個地方，分佈在南台灣各處！那麼當有新的套件的漏洞被發佈，
		或者是需要進行一些額外的設定的時候，是否鳥哥本人一定要到現場嗎？當然不需要，
		只要透過網路連線到該主機上面，就可以進行任何工作了！真的就好像在主機前面工作一般的輕鬆愉快！
		^_^！這就是遠端連線伺服器啦！<br /><br />

		遠端連線伺服器的功能當然還不只如此！舉個例子來說：當您的工作需要使用到
		Linux 的強大的編譯功能時，那麼您一定需要 Linux 對吧！而且最好是運算速度快一點的主機，
		這個時候您可以將您研究室最快的那一部主機開放出來，設定一下遠端連線伺服器，讓您的學生啦，
		或者是研究室的同仁啦，可以透過這部機器幫他們進行研究的工作，這個時候，您的主機就可以讓多人進行分享
		Linux 運算的功能啦！<br /><br />

		在早期的網路世界裡，由於只有 Unix 機器，而且個人電腦還不流行的時候，
		想要使用大型主機來進行數值程式的運算時(在我們工程界，比較常使用
		Fortran 這一類的程式語言，至於 C 語言則較少碰～)，就需要向學校單位申請 Unix 工作站的帳號，
		並且以遠端連線程式連進主機，以使用
		Unix 的資源來進行我們的數值模式運算！所以啦，那個遠端連線伺服器的設定，
		對於系統管理員是很重要的！尤其對於大型工作站類型的
		Unix-Like 主機，由於很多人都需要使用到他的運算功能，或者是他的編譯程式(
		compiler )來進行運算，這時的遠端連線就更形重要啦！<br /><br />

		那麼是否每一部連上 Internet 上面的主機都應該要開放遠端連線的功能呢？其實並不盡然，
		還是需要針對您的主機來進行規劃的，我們底下分伺服器與工作站來說明：<br /><br />

		<li><span class=text_import1>伺服器類型( Server )的連線程式</span>：</li>
		<div class=block2>
			在一般開放網際網路服務的伺服器中，由於開放的服務可能會有較為重要的資訊，
			而遠端連線程式連進主機之後，可以進行的工作又太多了(幾乎就像在主機前面工作一般！)，
			因此網際網路的遠端連線程式通常僅針對少部分系統維護者開放而已！
			<span class=text_import2>除非必要，否則
			Server 類型的主機還真的不建議開放連線的服務呢！</span>
			以鳥哥為例，我的主機提供了我們研究室使用
			Mail 與 Internet 上面的 WWW 服務，如果還主動提供遠端連線的話，
			那麼萬一不小心被入侵，那可就傷腦筋了！因此，鳥哥僅開放『很小部分的網域』讓系統管理員連進來，
			其他來源的 IP 一律抵擋！不許使用遠端連線的功能呢！<br /><br />
		</div>

		<li><span class=text_import1>工作站類型( Workstation )的連線程式</span>：</li>
		<div class=block2>
			至於工作站的情況就跟伺服器不太一樣了！工作站常常僅針對內部的幾個使用者開放而已，
			通常是不希望連上 Internet 的啦！而且所謂的工作站自然就是用來做工的！
			例如鳥哥的其中一部 Linux 就是專門用來進行大型的數值模式計算模擬之用！
			這個時候的遠端連線伺服器可能就得要對多人啟動了！
			因為工作站的強大運算功能可以讓很多人一同使用他的計算能力！而且也可以免除每部電腦都得要安裝
			compiler 的窘境！要知道，某些工程用的 compiler 是粉貴的～<br />
		</div>
	</div>

	<hr /><a name="remote_access_work"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class=text_h2>有哪些可供登入的類型？
	</span><br />
	<div class=block2>
		那麼目前遠端連線伺服器的主要類型有哪些？如果以顯示的類型來分類，
		基本上有文字介面與圖形介面兩種。<br /><br />

		在文字類型登入方面的伺服器，主要有以『明碼』傳送資料的
		telnet 伺服器，及以加密技術進行封包加密來傳送的 SSH 伺服器！雖然 telnet
		可以支援的 client 端軟體比較多，不過由於他是使用明碼來傳送資料，
		您的資料很容易遭到有心人士的擷取！所以近來我們都呼籲大家多使用
		SSH 這一種連線方式，而捨棄掉 telnet 這個比較不安全的咚咚囉！<br /><br />

		至於圖形介面的伺服器，比較簡單的有 Xdmcp ，架設 Xdmcp 很簡單，
		不過 client 端的軟體比較少。另外一款目前很常見的伺服器，就是 VNC (Virtual Network Computing)，
		透過 VNC server/client 軟體來進行連接。圖形介面最大的優點是『圖形』啊！
		不過，因為是透過圖形來傳送，傳輸的資料量相當的大，所以速度與安全性都有待考量。
		因此，我們僅建議您將圖形介面的遠端登入伺服器開放在內部網域 (LAN) 就好了！<br /><br />

		那麼什麼是『明碼』與『加密』的資料封包傳送模式呢？
		為什麼 telnet 使用明碼就比較不安全？所謂的明碼就是：
		『<span class=text_import2>當我們的資料封包在網路上流竄時，該資料封包的內容為資料的原始格式</span>』，
		還記得我們在<a href="0140networkcommand.htm#tcpdump">網路常用指令章節當中介紹的 tcpdump</a> 吧？
		我們在 telnet 下達的指令與密碼等等，都會以類似 ASCII 的格式傳送到主機端，
		而主機端就藉由這些資料來下達指令。如果這些資料封包在經過某些
		broadcast 或者是 Router 時，被有心人士捉去，那麼他將會完整的取得您的資料喔！
		所以啦，萬一您的資料封包裡面含有信用卡資料、密碼、身份確認等重要資訊時，是否很危險吶？！
		因此，目前我們通常都希望使用可以將這些在網路上面跑的資料加密的技術，以增加資料在
		Internet 上面傳送的安全性啊！<br />
	</div>
</div>

<hr /><a NAME="telnet"></a><img src="/images/penguin-m.gif" alt="大標題的圖示" height="34" width="25" align="middle" /><span class="text_h1">Telnet 伺服器</span><br />
<div class=block1>
	知道 telnet 是什麼嗎？咦！不就是連接 BBS 的工具嗎？沒錯！他確實也是
	BBS 軟體類的一個伺服器啦！不過這裡我們暫不玩弄 BBS ！ telnet 
	可以說是歷史相當悠久的遠端連線伺服器哩！而且支援他的軟體也相當的多！例如知名的
	netterm 就直接支援他啦！連線之後的界面也漂亮，在 client 端的中文傳輸與輸入也沒有問題！
	相當的不錯用！不過，他最麻煩的地方就是.....比較不安全而已啦～<br /><br />

	底下我們談一談怎麼啟動與使用 telnet 伺服器吧！<br /><br />

	<hr /><a name="telnet_start"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class=text_h2>安裝、啟動與關閉服務
	</span><br />
	<div class=block2>
		<li><span class=text_import1>安裝：</span></li>
		<div class=block2>
		近年來由於 telnet 是以明碼在傳輸的問題，所以在新的 Linux 版本上面，<span class=text_import2>已經都將
		telnet 這個伺服器排除在『先發名單』之外啦</span>，也就是說，很多 Linux
		distributions 預設是不安裝 telnet 的，不過，在每個主要的 Linux distributions
		<span class=text_import2>還是有提供
		telnet 套件在光碟當中啦</span>！所以您要拿出原版光碟，並且安裝好他就可以用啦！如何確認是否已經安裝了
		telnet 呢？最簡單的方法就是使用最廣泛被使用的 RPM 啦！<br />

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>rpm -qa | grep telnet</span>
telnet-0.17-31.EL4.3
telnet-server-0.17-31.EL4.3
<span class=term_say># 上面是 CentOS 4.x 預設的套件版本。如果是其他的 distribution，
# 檔名可能會不太一樣～可利用 yum 或 apt 等方式來安裝喔！</span>
</pre></td></tr></table>

		需要特別留意的是，如果要提供 telnet 連線服務，通常需要安裝兩個 RPM 喔：
		<ol><span class=text_import2>
		<li>一個是 telnet，這個套件提供的是 telnet 用戶端的連線程式；</li>
		<li>另一個是 telnet-server 套件，這個才是真正的 Telnet server 軟體喔！</li></span>
		</ol>
		如果找不到 telnet-server 的話，請拿出原版光碟來安裝，或者直接使用 yum 吧！
		否則就無法進行下一步的設定啦！^_^<br /><br />
		</div>

		<li><span class=text_import1>啟動與關閉：</span></li>
		<div class=block2>
		還記得『<a href="../linux_basic/">鳥哥的 Linux 私房菜 -- 基礎學習篇</a>』裡面的
		『<a href="../linux_basic/0560daemons.htm">認識服務( daemon )</a>』那個章節吧？
		要記得 super daemon 呦！因為我們的
		telnet 就是掛在 super daemon 底下的一支服務而已！那個咚咚就是有名的 xinetd 囉！<br />

		<div style="padding: 10pt 0pt 10pt 0pt ;" align="right"><table width="90%"><tr><td><b>Tips:</b><br /><span style="color : #009000"><font size="-1">			在某些舊版的套件上面也有使用 inetd 的，啟動的方式有點不太一樣，不過差異不大啦！
			只要懂得基本的常識，那麼就不會有問題囉！所以鳥哥才會要大家先讀完
			<a href="../linux_basic/">Linux 基礎篇</a> 啦！
		</font></span></td><td><img src="/images/vbird_face.gif" alt="鳥哥的圖示" title="鳥哥的圖示" /></td></tr></table></div>
		啟動的方式就是：

		<ol><span class=text_import2>
		<li>將 xinetd 裡面關於 telnet 的項目開啟，然後
		<li>重新啟動一次 xinetd 就成功啦！</span></ol>

		那麼如何開啟 telnet 的項目呢？很簡單，有兩個方式：
		<ol>
		<li><span class=text_import2>使用 ntsysv 或
		<a href="../linux_basic/0560daemons.htm#chkconfig">chkconfig</a>：</span></li>
		還記得 Red Hat 系列(含 CentOS)的套件裡面的 <a href="../linux_basic/0560daemons.htm#ntsysv">ntsysv</a>
		這個好用的東西嗎？對了，在 CentOS 底下有這麼一個好用的設定工具，您可以使用
		<a href="../linux_basic/0560daemons.htm#ntsysv">ntsysv</a>
		出現的視窗之中，將 telnet 勾選起來，然後按下 OK 離開即可囉！<br /><br />
		<li><span class=text_import2>使用 <a href="../linux_basic/0310vi.htm">vi</a> 修改
		/etc/xinetd.d/telnet 這個檔案：</span></li>
		那麼如果不是 Red Hat 系列的 Linux 系統呢？基本上， ntsysv 也只是修改 /etc/xinetd.d
		這個目錄下的資料而已，所以我們當然可以手動自己修改他啦！<br />

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>vi /etc/xinetd.d/telnet</span>
service telnet
{
        flags           = REUSE
        socket_type     = stream
        wait            = no
        user            = root
        server          = /usr/sbin/in.telnetd
        log_on_failure  += USERID
<span class=term_write>#       disable         = yes
        disable         = no</span>
<span class=term_say># 基本上，改上面這兩行就夠了！將 disable 設定成 no 表示要啟動！</span>
}
</pre></td></tr></table>

		</ol>

		設定完開啟之後，自然就是要啟動啦，剛剛提到 <span class=text_import2>telnet
		是掛在 xinetd 底下的，所以自然只要重新啟動 xinetd 就能夠將 /etc/xinetd.d/ 裡頭的設定重新讀進來</span>，
		所以剛剛設定啟動的
		telnet 自然也就可以被啟動啦！而啟動的方式也有兩種方式，其中 service 這個指令僅支援在
		CentOS 與 Mandriva 底下，所以通常鳥哥還是以 /etc/init.d 底下的 scripts
		為啟動的主要方法啦！<br />

<table class="term"><tr><td class="term"><pre>
<span class=term_hd>僅適合 Red Hat 系列 / Mandriva 系列的主機啟動方式</span>
[root@linux ~]# <span class=term_command>service xinetd restart</span>
Stopping xinetd:                       [  OK  ]
Starting xinetd:                       [  OK  ]

<span class=term_hd>適合各版本的主機啟動方式</span>
[root@linux ~]# <span class=term_command>/etc/init.d/xinetd restart</span>
Stopping xinetd:                       [  OK  ]
Starting xinetd:                       [  OK  ]
<span class=term_say># 某些版本並沒有 restart 的選項，這個時候就需要：stop 再 start 囉！</span>
</pre></td></tr></table>

		那麼要看有沒有啟動服務呢？怎麼看？其實也很簡單啦，還記得我們在前幾章提到的『
		<a href="0210port_limit.htm">限制 Linux port 的連線</a> 』那一章嗎？使用
		<a href="0140networkcommand.htm#netstat">netstat</a>
		就可以啦！<br />

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>netstat -tlup</span>
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address  Foreign Address   State   PID/Program name
tcp        0      0 *:telnet       *:*               LISTEN  23817/xinetd
</pre></td></tr></table>

		看到了嗎？沒錯，那個 telnet 就是啟動的項目啦！那麼要如何關閉呢？呵呵！
		那就真的是太簡單啦！就將剛剛的步驟再做一次，而將設定值轉變一下即可！步驟如下啦！<br />

		<div style="padding: 10pt 0pt 10pt 0pt ;" align="right"><table width="90%"><tr><td><b>Tips:</b><br /><span style="color : #009000"><font size="-1">			這裡考一個問題，那個 port 對應的服務名稱在哪一個檔案裡面查詢到的呢？
			在每一個 Linux 系統都有的檔案呦！忘記了呀！？再回到前面看看
			<a href="0210port_limit.htm">限制 Linux port 的連線</a> ，
			然後用 <a href="../linux_basic/0310vi.htm">vi</a> 去看看那一個檔案的內容吧！ ^_^ 
		</font></span></td><td><img src="/images/vbird_face.gif" alt="鳥哥的圖示" title="鳥哥的圖示" /></td></tr></table></div>
<table class="term"><tr><td class="term"><pre>
<span class=term_hd>Step 1: 修改設定檔</span>
[root@linux ~]# <span class=term_command>vi /etc/xinetd.d/telnet</span>
service telnet
{
        flags           = REUSE
        socket_type     = stream
        wait            = no
        user            = root
        server          = /usr/sbin/in.telnetd
        log_on_failure  += USERID
        disable         = yes  <span class=term_say>&lt;== 就是這裡啦！將他改成 yes 就是關閉！</span>
}

<span class=term_hd>Step 2: 重新啟動 xinetd 這個 super daemon</span>
[root@linux ~]# <span class=term_command>/etc/init.d/xinetd restart</span>
</pre></td></tr></table>

		</div>
	</div>

	<hr /><a name="telnet_client"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class=text_h2>好用的連線軟體</span><br />
	<div class=block2>
		剛剛上面提到的都是在伺服器端的設定而已！那麼在客戶端有什麼好用的軟體可以連上 
		Server 的呢？最常見到的應該就是 netterm 這個鼎鼎大名的連線軟體了吧！
		我想，只要玩過 BBS 的大概都曉得這個軟體才對！所以這裡就不提了！
		另外，目前幾乎所有的作業系統都提供了 telnet 這個程式，這個程式可以直接輕易的就連上 
		telnet server 呢！例如您要在 Linux 上面連上自己的 telnet 伺服器，可以這樣做：<br />

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>telnet localhost</span>
Trying 127.0.0.1...
Connected to localhost.localdomain (127.0.0.1).
Escape character is '^]'.
CentOS release 4.4 (Final)
Kernel 2.6.9-42.0.2.EL on an i686
login: <span class=term_command>dmtsai</span>    <span class=term_say>&lt;== 就是這裡啦！請輸入『一般』帳號，不能用 root 喔！</span>
Password:         <span class=term_say>&lt;== 這裡輸入該帳號的密碼！請注意，輸入時，螢幕不會有任何資訊！</span>
Last login: Fri Jul  1 09:31:21 from 127.0.0.1  <span class=term_say>&lt;== 上次登入的資訊為何?</span>
[dmtsai@linux ~]$ <span class=term_say>&lt;== 這裡就是已經登入的地方！亦即遠端主機了！</span>
[dmtsai@linux ~]$ <span class=term_command>exit</span>    <span class=term_say>&lt;== 這樣就能夠離開 telnet 與遠端主機咯！</span>
</pre></td></tr></table>

		這樣就連線進來啦！很簡單吧！那麼在 Windows 的環境底下呢？同樣的，也是可以使用
		telnet 的程式連線到 Linux 的 telnet server 裡面來！沒有問題的啦！可以依序這樣做：

		<ol><span class=text_import2>
		<li>按下 Windows 內的 『開始』
		<li>選擇 『執行』
		<li>在出現的視窗中輸入 『telnet your.IP.or.hostname』</ol></span>

		這樣就可以進入 Linux 的環境中了！很方便吧！當然啦！您也可以使用類似
		netterm 這個很棒的連線軟體來連線的，這裡我們就不示範啦！<br />

		<div style="padding: 10pt 0pt 10pt 0pt ;" align="right"><table width="90%"><tr><td><b>Tips:</b><br /><span style="color : #009000"><font size="-1">		在 Linux tty1 ~ tty6 的終端機預設模式下，我們是沒有辦法看到中文的！
		除非安裝某些特殊的中文介面才行！比如 JMCCE 之類的咚咚！
		因為不是很重要，所以鳥哥這裡就不加介紹了。 ^_^
		</font></span></td><td><img src="/images/vbird_face.gif" alt="鳥哥的圖示" title="鳥哥的圖示" /></td></tr></table></div>
		另外，需要先留意的是，為了系統安全的考量，<span class=text_import2>預設的 telnet 
		是『不允許』使用 root 這個帳號登入的～</span>
		這個很重要喔！您不要使用 root 嘗試登入 telnet 啊！ ^_^
	</div>

	<hr /><a name="telnet_safe"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class=text_h2>iptables, TCP_Wrappers, 純建議</span><br />
	<div class=block2>
		telnet 這個伺服器方便歸方便，但<span class=text_import2>總是一個不太好的連線解決方案</span>，
		因為畢竟他是一個以『明碼』傳輸的協定，所以很不適合在 Internet 上面使用啦！
		你總不希望你的帳號密碼在 Internet 上面被竊取吧？不過，如果 telnet 是啟動在內部環境當中那就還好啦！
		尤其有些朋友因為舊軟體的關係，還是需要使用到 telnet 來連線。那麼我們就提一些基本的注意事項好了！<br /><br />

		<li><span class=text_import1>以比較限制的設定檔來規範連線的 IP ：</span></li>
		<div class=block2>
			事實上， xinetd 就已經提供些許的保護措施了，
			您可以針對您主機的多重介面(有對內以及對外喔！)來提供不同保護等級的措施！
			底下列出一個範例，不過，更多的資訊請再回到『<a href="../linux_basic/">鳥哥的
			Linux 私房菜 -- 基礎學習篇</a>』當中去查閱一下
			『<a href="../linux_basic/0560daemons.htm">認識服務</a>
			』那一章裡面的詳細設定說明，或者直接 man xinetd.conf 吧！<br />

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>vi /etc/xinetd.d/telnet</span>
<span class=term_say># This file had been modified by VBird 2002/11/04
# 首先為內部網路的參數設定</span>
service telnet
{
        disable         = no
<span class=term_write>        bind            = 192.168.1.2
        only_from       = 192.168.1.0/24</span>
        <span class=term_say># 上面這兩行說明僅提供內部網域！</span>
        instance        = UNLIMITED
        nice            = 0
        flags           = REUSE
        socket_type     = stream
        wait            = no
        user            = root
        server          = /usr/sbin/telnetd
        server_args     = -a none
        log_on_failure  += USERID
}

<span class=term_say># 再來則是針對外部網域的設定</span>
service telnet
{
        disable         = no
<span class=term_write>        bind            = 140.116.142.196
        only_from       = 140.116.0.0/16
        no_access       = 140.116.32.{10,26}</span>
        <span class=term_say># 上面這三行設定外部較為嚴格的限制</span>
        instance        = 10   <span class=term_say>&lt;==最多允許同時 10 個連線</span>
        umask           = 022
        nice            = 10
        flags           = REUSE
        socket_type     = stream
        wait            = no
        user            = root
        server          = /usr/sbin/telnetd
        server_args     = -a none
        log_on_failure  += USERID
}
</pre></td></tr></table>
		</div>
		<li><span class=text_import1>root 不能直接以 telnet 連接上主機：</span></li>
		<div class=block2>
			<span class=text_import2>既然 telnet 不是很安全，自然預設的情況之下就是無法允許
			root 以 telnet 登入 Linux 主機的</span>！但事實上， telnet 
			只是利用一些較為安全的機制 (其實就是 PAM 模組啦) 來防止
			root 登入而已～所以囉，假如您確定您的環境夠安全(例如您的主機並沒有連上
			Internet )，並且想要開放 root 以 telnet 登入 Linux 主機的話，請直接將 /etc/securetty
			更改檔名即可！<br />

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>mv /etc/securetty /etc/securetty.bak</span>
</pre></td></tr></table>

			這樣一來，root 就可以登入啦！不過，相當的不建議這樣做喔！畢竟不是很安全啦！此外，您也可以藉由修改
			pam 模組來達成同樣的功能！修改 /etc/pam.d/login 這個檔案的第二行設定即可：

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>vi /etc/pam.d/login</span>
#%PAM-1.0
<span class=term_write>#auth       required     pam_securetty.so</span>  <span class=term_say>&lt;== 就是這樣一行，將他註解即可！</span>
auth       required     pam_stack.so service=system-auth
auth       required     pam_nologin.so
account    required     pam_stack.so service=system-auth
password   required     pam_stack.so service=system-auth
# pam_selinux.so close should be the first session rule
session    required     pam_selinux.so close
session    required     pam_stack.so service=system-auth
session    required     pam_loginuid.so
session    optional     pam_console.so
# pam_selinux.so open should be the last session rule
session    required     pam_selinux.so multiple open
</pre></td></tr></table>

		如此一來， root 將可以直接進入 Linux 主機了！不過，既然我們可以透過 su 或 sudo 來切換身份，
		那麼幹嘛還需要開放 root 用 telnet 登入主機呢？真是沒必要～所以，
		<span class=text_import1>還是不建議如此做的</span>！<br /><br />
		</div>

		<li><span class=text_import1>加上防火牆 iptables：</span></li>
		<div class=block2>
			針對 telnet 加設防火牆 iptables 是一個好主意！如果您已經參考了前面章節提到的『
			<a href="0250simple_firewall.htm">簡易防火牆架設</a> 』一文，並且使用裡面的
			scripts 的話，那麼不用擔心 telnet 啦！基本上，他原本就僅對內部開放 telnet
			，外部是無法連上您的 telnet 的！但是，若是您自己設定了自己的防火牆機制之後，那麼想要針對
			192.168.0.0/24 這個網域，及 61.xxx.xxx.xxx 這個 IP 進行 telnet 的開放呢？可以增加這幾行在您的
			iptables 規則之內(請注意：防火牆的規則順序是很重要的！所以再回頭看看 
			<a href="0250simple_firewall.htm">簡易防火牆架設</a> 一文是有必要的！)<br />

<table class="term"><tr><td class="term"><pre>
<span class=term_write>iptables -A INPUT -p tcp -i $INIF  -s 192.168.0.0/24 --dport 23 -j ACCEPT
iptables -A INPUT -p tcp -i $EXTIF -s 61.xxx.xxx.xxx --dport 23 -j ACCEPT
iptables -A INPUT -p tcp -i $EXTIF                   --dport 23 -j DROP</span>
</pre></td></tr></table>

			上面的規則中，$EXTIF 指的是對外的連線介面，$INIF 則是對內的介面。
			第一、二行是針對來源的 IP 來開放 port 23 亦即是 telnet 的協定啦！
			而最後一行則是將其他的所有來源的，想要連上
			telnet 的連線封包都丟掉的意思！怎麼樣！很簡單吧！<br /><br />
		</div>

		<li><span class=text_import1>加上防火牆 /etc/hosts.allow(deny) 機制：</span></li>
		<div class=block2>
			防火牆的機制是越多越好！永遠也不嫌多的啦！這裡也可以使用 TCP_Wrappers
			的機制呢！剛剛是開放了 192.168.0.0/24 這個網段，但是如果您只想要其中的
			192.168.0.1 ~ 192.168.0.5 進入呢？而其他的 IP 只要一經連線，就會被記錄該
			IP ，以提供 root 查詢呢？可以這樣做：<br />

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>vi /etc/hosts.allow</span>
in.telnetd: 192.168.0.1, 192.168.0.2, 192.168.0.3, 192.168.0.4
in.telnetd: 192.168.0.5

[root@linux ~]# <span class=term_command>vi /etc/hosts.deny</span>
in.telnetd : ALL : spawn (/bin/echo Security notice from `/bin/hostname`; \
/bin/echo; /usr/sbin/safe_finger @%h ) | \
/bin/mail -s "%d -%h security" root@localhost & \
: twist ( /bin/echo -e "\n\nWARNING connectin not allowed. \n\n\n" )
</pre></td></tr></table>

		</div>

		<li><span class=text_import1>建議事項：</span></li>
		<div class=block2>
			事實上， telnet 最大的不安全在於資料是以明碼傳輸，所以在 Internet 
			這個大家都能夠連上的地方來傳輸資料時，實在很不安全！所以：
			<ol><span class=text_import2>
			<li>非必要時，不要啟動 telnet ，如果真的需要啟動 telnet
			，那麼也請在啟動並且使用完畢之後，立即將他關掉！</li>
			<li>如果確定真的要啟動 telnet 時，請確定好限制的連線範圍，使用
			iptables 來設定連線的限制區域；</li>
			<li>加上 TCP_Wrappers 的輔助，加強防火牆的功能！</li>
			<li>隨時注意登錄檔案裡面關於 login 的事項！並且不要讓
			root 能以 telnet 登入 Linux 主機！</li>
			</span></ol>
		</div>
	</div>
</div>

<hr /><a NAME="ssh"></a><img src="/images/penguin-m.gif" alt="大標題的圖示" height="34" width="25" align="middle" /><span class="text_h1">SSH 伺服器</span><br />
<div class=block1>
	既然 telnet 的資料在 Internet 上不是很安全，那麼我又需要以遠端連線服務來操控我的 Linux
	主機，那麼應該怎麼辦呀？最好的方法當然就是以較為安全的連線機制來解決連線的問題囉！
	那麼該如何解決這樣的問題呢？這也不難啦，使用
	SSH 即可。那麼 SSH 是什麼呢？他有什麼特異功能？<br /><br />

	簡單的來說，<span class=text_import2>SSH
	是 <b>S</b>ecure <b>SH</b>ell protocol 的簡寫</span>，他可以經由將連線的封包加密的技術，
	來進行資料的傳遞，因此，資料當然就比較安全囉！這個
	SSH 可以用來取代 Internet 上面較不安全的 finger, R Shell (rcp, rlogin,
	rsh 等指令), talk 及 telnet 等連線模式。底下我們將先簡介一下 SSH 的連線模式，來說明為什麼
	SSH 會比較安全呢！<br /><br />

	特別注意：這個 SSH 協定，在預設的狀態中，本身就提供兩個伺服器功能：
	<ol><span class=text_import2>
	<li>一個就是類似 telnet 的遠端連線使用 shell 的伺服器，亦即是俗稱的 ssh ；</li>
	<li>另一個就是類似 FTP 服務的 sftp-server ！提供更安全的 FTP 服務。</li>
	</span></ol><br />

	<hr /><a name="ssh_connect"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class=text_h2>連線加密技術簡介：</span><br />
	<div class=block2>
		什麼是『資料加密』呢？簡單的說，就是將人們看的懂得電子資料，經過一些運算，
		讓這些資料變成沒有意義的(至少對人類來說)咚咚，然後這個咚咚可以在網路上面傳輸，
		而當使用者想要查閱這個資料時，再透過反向運算，將這些咚咚反推出原始的電子資料。
		由於這些資料已經被重新處理過，所以，即使資料在 Internet 上被 cracker 
		監聽而竊取，他們也不容易就推算得出來原始資料內容的。<br /><br />

		網路封包的加密技術通常是藉由所謂的『<span class=text_import2>一對公鑰與私鑰</span>』
		亦即『<span class=text_import2>Public and Private 組合成的 key pair</span>』
		來進行加密與解密的動作！如下圖所示。主機端所要傳給 client 端的資料，會先經由公鑰加密後才到網路上傳輸。
		而到達 client 端之後，再經由私鑰將加密的資料解開來～由於在 Internet 上面跑的資料是加密過後的，
		所以你的資料內容當然就比較安全啦！<br /><br />

		<center><img src="0310telnetssh/0310telnetssh-1.jpg" 
			title="公鑰與私鑰在進行資料傳輸時的角色示意圖"
			alt="公鑰與私鑰在進行資料傳輸時的角色示意圖"><br />
			圖一、公鑰與私鑰在進行資料傳輸時的角色示意圖</center><br />

		<div style="padding: 10pt 0pt 10pt 0pt ;" align="right"><table width="90%"><tr><td><b>Tips:</b><br /><span style="color : #009000"><font size="-1">			資料加密的技術真的相當的多，也各有其優缺點，有的運算速度快，
			但是不夠安全；有的夠安全，但是加密/解密的速度較慢～
			目前在 SSH 使用上，主要是利用 RSA/DSA/Diffie-Hellman 等機制喔！
		</font></span></td><td><img src="/images/vbird_face.gif" alt="鳥哥的圖示" title="鳥哥的圖示" /></td></tr></table></div>
		那麼這些公鑰與私鑰是如何產生的呢？底下我們來談一談目前
		SSH 的兩種版本的連線模式囉！<br /><br />

		<li><span class=text_import1>SSH protocol version 1</span>：</li>
		<div class=block2>
			每一部 SSH 伺服器主機都可以使用 RSA 加密方式來產生一個 1024-bit 的 RSA Key ，
			這個 RSA 的加密方式，主要就是用來產生公鑰與私鑰的演算方法！這個 
			version 1 的整個連線的加密步驟可以簡單的這麼看：

			<ol><span class=text_import2>
			<li>當每次 SSH daemon (sshd) 啟動時，就會產生一支 768-bit 
			的公鑰(或稱為 server key)存放在 Server 中；</li>
			<li>若有 client 端的 ssh 連線需求傳送來時，那麼 Server 就會將這一支公鑰傳給 
			client ，此時 client 也會比對一下這支公鑰的正確性。比對的方法為利用 
			/etc/ssh/ssh_known_hosts 或 ~/.ssh/known_hosts 檔案內容。</li>
			<li>在 Client 接受這個 768-bit 的 server key 之後，Client 自己也會隨機產生一支
			256-bit 的私鑰(host key)，並且以加密的方式將 server key 與 host key 整合成一對完整的
			Key pair，並且將這對 Key pair 也傳送給 server ；</li>
			<li>之後，Server 與 Client 在這次的連線當中，就以這一對 1024-bit 的 Key pair 來進行資料的傳遞！</li>
			</ol></span>

			也就是說，Public Key 是放在 Server 上的，而 Client 端的軟體必須要能接受 Public Key 以及計算出
			Private Key 以組合成為一把獨一無二的 key pair ，因為 Client 端每次的 256-bit 的 Key 
			是隨機取的，所以您這次的連線與下次的連線的 Key 可能就會不一樣啦！此外在 Client 端的使用者家目錄下的
			~/.ssh/known_hosts 會記錄曾經連線過的主機的 public key ，用以確認每次來自該主機的連線是正確的。
			這個 ~/.ssh/known_hosts 檔案的意義後續還會介紹的。<br />

		</div>
		<li><span class=text_import1>SSH protocol version 2</span>：</li>
		<div class=block2>
		在 SSH version1 的連線過程當中，當 server 端接受 client 端的 private key 後，就不再針對該次連線的
		key pair 進行檢驗。此時若有惡意的 cracker 針對該連線給予惡意的程式碼時，由於主機端不會檢驗連線的正確性，
		因此可能會接受該程式碼，進一步造成系統被黑掉的問題。<br /><br />

		為了改正這個缺失，SSH version 2 多加了一個確認連線正確性的 Diffie-Hellman 機制，
		在每次資料的傳輸當中 server 端都會以該機制檢查資料的來源是否正確，
		所以可以避免連線過程當中被插入惡意程式碼的問題！
		也就是說， ssh version 2 是比較安全的喔！<br /><br />
		</div>

		由於 SSH version 1 本身存在著的一些問題，因此，近來我們都希望大家使用 ssh version 2 的連線模式，
		會比較安全一點。而連線版本的設定則需要在 ssh 主機端與客戶端均設定好才行喔！<br /><br />
	</div>

	<hr /><a name="ssh_start"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class=text_h2>啟動 SSH 服務：</span><br />
	<div class=block2>
		事實上，在我們使用的 Linux 系統當中，預設就已經含有 SSH 的所有需要的套件了！
		這包含了可以產生密碼等協定的 <a href="http://www.openssl.org" target="_blank">OpenSSL</a>
		套件與 <a href="http://www.openssh.com/" target="_blank">OpenSSH</a> 
		套件，所以呢，要啟動 SSH 真的是太簡單了！就直接給他啟動就是了！此外，在目前的 
		Linux Distributions 當中，<span class=text_import2>都是預設啟動 SSH 的</span>，
		所以一點都不麻煩，因為不用去設定，他就已經啟動了！哇！真是爽快～無論如何，
		我們還是得說一說這個啟動的方式吧！直接啟動就是以
		SSH daemon ，簡稱為 sshd 來啟動的，所以，手動可以這樣啟動：<br />

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>/etc/init.d/sshd restart</span>
[root@linux ~]# <span class=term_command>netstat -tlp</span>
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address  Foreign Address  State   PID/Program name
tcp        0      0 *:ssh          *:*              LISTEN  24266/sshd
</pre></td></tr></table>

		啟動後，利用 <a href="0140networkcommand.htm#netstat">netstat</a> 查閱一下
		sshd 這個程序是否正確的在 LISTEN 即可！當然，這個時候您的 SSH 伺服器設定值均是使用系統預設值，
		能不能夠僅用較安全的 version 2 ，則需要進一步的設定呢。
		接下來，如果您想要在開機就啟動 SSH 的話(預設也是啟動的！)，可以利用
		<a href="../linux_basic/0560daemons.htm#chkconfig">chkconfig</a>
		來設定開機啟動即可。<br /><br />

		雖然新的 Linux distributions 都預設會有 SSH 存在的，但是較舊的版本就僅有 telnet 而已。
		例如 Red Hat 6.x 之前的版本。那麼如果您想要在舊的 distributions 當中安裝 SSH 該如何是好？
		嘿嘿！可以參考一下鳥哥之前寫過的一篇咚咚，有詳細的說明 tarball 的安裝流程哩！

		<ul><a href="0310telnetssh/0310telnetssh-2.htm">使用 Tarbal 安裝 SSH 以及升級 SSH 可能會遇到的問題說明<br />
		(http://linux.vbird.org0310telnetssh/0310telnetssh-2.htm)</a></ul>

		需要注意的是， SSH 不但提供了 shell 給我們使用，亦即是 ssh protocol
		的主要目的，同時亦提供了一個較為安全的 FTP server ，亦即是 ssh-ftp server
		給我們當成是 FTP 來使用！所以，<span class=text_import2>這個 sshd 可以同時提供
		shell 與 ftp 喔！而且都是架構在 port 22 上面的呢</span>！所以，底下我們就來提一提，那麼怎麼樣由
		Client 端連接上 Server 端呢？同時，如何以 FTP 的服務來連接上 Server 並且使用
		FTP 的功能呢？<br /><br />
	</div>

	<hr /><a name="ssh_client"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class=text_h2>ssh 用戶端連線：</span><br />
	<div class=block2>
		由於 Linux 與 Windows 這兩個用戶端 Client 連線軟體/指令並不一樣，所以我們分別來介紹可以使用的指令：<br /><br />

		<li><a name="ssh_client_ssh"></a><span class=text_import1>Linux Client: ssh</span></li>
		<div class=block2>
			SSH 在 client 端使用的是 ssh 這個指令，這個指令可以指定連線的版本 (version1, version2)，
			還可以指定非正規的 ssh port (正規 ssh port 為 22)。不過，一般的用法可以使用底下的方式：<br />

<table class="term"><tr><td class="term"><pre>
<span class=term_hd>1. 直接登入到對方主機的方法：</span>
[root@linux ~]# <span class=term_command>ssh account@hostname</span>
<span class=term_say># 連接到我們自己本機上面的 ssh 服務！更多訊息，請 man ssh 喔！</span>
[root@linux ~]# <span class=term_command>ssh dmtsai@localhost</span>
The authenticity of host 'localhost (127.0.0.1)' can't be established.
RSA key fingerprint is f8:ae:67:0e:f0:e0:3e:bb:d9:88:1e:c9:2e:62:22:72.
Are you sure you want to continue connecting (yes/no)? <span class=term_command>yes</span>
<span class=term_say># 上面很重要喔！務必填入完整的 "yes" 而不是 Y 或 y 而已。</span>
Warning: Permanently added 'localhost' (RSA) to the list of known hosts.
dmtsai@localhost's password: <span class=term_say>&lt;== 在這裡填入密碼，同樣的，螢幕不會有訊息的！</span>
Last login: Fri Jul  1 14:23:27 2005 from localhost.localdomain
[dmtsai@linux ~]$      <span class=term_say>&lt;== 瞧！已經登入囉～</span>
[dmtsai@linux ~]$ <span class=term_command>exit</span> <span class=term_say>&lt;== 輸入 exit 就能夠離開對方主機囉！</span>

<span class=term_hd>2. 不登入對方主機，直接在對方主機執行指令的方法：</span>
[root@linux ~]# <span class=term_command>ssh dmtsai@localhost date</span>
dmtsai@localhost's password:
Tue Nov 22 11:57:27 CST 2005
[root@linux ~]# 
<span class=term_say># 看！身份還是 root 喔！只是以 dmtsai 的身份在遠端主機上執行了一個指令而已！</span>
</pre></td></tr></table>

			這裡請特別留意的是，如果直接以『 <span class=text_import2>ssh hostname</span>
			 』這個指令來連接進入 hostname 這個主機時，則<span class=text_import2>進入 hostname 
			這個主機的『帳號名稱』將會是目前您所在的這個環境當中的使用者帳號！</span>
			以上面為例，因為我是以 root 的身份在執行，所以如果我執行了『 ssh host.domain.name 』時，
			那麼對方 host.domain.name 這部主機，就會以 root 的身份來讓我進行密碼確認的登入動作！<br /><br />

			因此，為了避免這樣的麻煩，通常鳥哥都是以簡單的 e-mail 的寫法來登入遠方的主機，
			例如『<span class=text_import2>ssh user@hostname </span>』即表示，
			鳥哥是以 user 這個帳號去登入 hostname 這部主機的意思。當然，也可以使用 
			-l username 這樣的形式來書寫！登入對方主機之後，其他的所有執行行為都跟在
			Linux 主機內沒有兩樣～所以，真的是很簡單吧！ ^_^ 這樣就可以達到遠端控管主機的目的了！<br /><br />

			此外，<span class=text_import2>在預設的情況下， SSH 是『允許您以 root 的身份登入』喔</span>
			！呵呵！更是爽快啦！要特別留意的是，當您要連接到對方的主機時，如果是首次連接，那麼
			Server 會問您，您的連線的 Key 尚未被建立，要不要接受 Server 傳來的 Key
			，並建立起連線呢？呵呵！這個時候請『<span class=text_import2>務必要輸入 yes
			而不是 y 或 Y</span>』，這樣程式才會接受喔！<br /><br />

			<li><span class=text_import1>關於 Server Keys 的紀錄資料： ~/.ssh/known_hosts</span></li>
			<div class=block2>
			如果您剛剛有研究過 SSH 的連線流程的話，會發現到當 client 端接受來自 server 端的 
			public key 之後，會主動的比對這支 Key 的正確性。而比對的檔案是 ~/.ssh/known_hosts 。
			若是接受到的這支 public key 並沒有被紀錄在這檔案內，那麼上面表格的訊息，
			就是要您回答 yes/no 的那個訊息才會出現～而您回答 yes 之後，該 public key 
			資訊就會被記錄起來，以留待下次登入同一部主機時的檢查之用啊！
			<span class=text_import2>如果 Server Key 與 ~/.ssh/known_hosts 比對成功，
			那麼您就會直接進入等待密碼輸入的畫面，</span>
			那就不必每次都得要輸入 (yes/no) 囉～<br /><br />

			不過，您或許也會發現一件事情啊，我們知道 SSH server 雖然使用 version 2 已經不會重複製造 
			server key (public key) 了，但是如果該主機重新安裝過新的 linux distributions 時，
			那把 server key 就會被改變啊！而 client 又會去比對這個 public key 與 ~/.ssh/known_hosts ，
			此時 Client 就會發現兩者不同了，於是乎產生如下的錯誤訊息了：<br />

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>ssh dmtsai@localhost</span>
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that the RSA host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
f8:ae:67:0e:f0:a0:3e:aa:d9:77:19:c9:2e:62:22:72.
Please contact your system administrator.
Add correct host key in /root/.ssh/known_hosts to get rid of this message.
Offending key in /root/.ssh/known_hosts:1
RSA host key for localhost has changed and you have requested strict checking.
Host key verification failed.
</pre></td></tr></table>

			這個錯誤訊息在告訴您，上次所登錄的遠端 SSH 主機的 Keys 
			已經被改過了(最可能的原因就是 Server 端重新開機/重新安裝/更新套件等等啦！)，
			所以無法繼續登入～呵呵！這個時候怎麼辦？很簡單啊！<span class=text_import2>進入您的家目錄的
			~/.ssh 裡面，編輯一下 known_hosts ，將欲連接的主機名稱的 Key 給他消除</span>，就可以重新連線啦！<br />

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>vi ~/.ssh/known_hosts</span>
localhost ssh-rsa AAAAB3NzaC1yc2Euowireffodjoiwjefmoeiwhoqhwupoi
t[egmlomowimvoiweo6VpTHTw2/tENp4U7Wn8J6nxYWP36YziFgxtWu4MPSKaRmr
E4eUpR1G/zV3TkChRZY5hGUybAreupTVdxCZvJlYvNiejfijoejwiojfijeoiwx5
eRkzvSj7a19vELZ5f8XhzH62E=
</pre></td></tr></table>

			上面表格的內容其實是同一行的～那一行代表『 localhost 這部主機，利用的是 ssh-rsa 連線機制，
			而後續的資料則是那把 Server Key 的內容。』如果您確定這次的比對無法成功是正常的，
			那麼您可以將這一行給他刪除，這樣下次要再登入時，就又會再次的出現問 (yes/no) 的畫面啊！<br /><br />
			</div>
		</div>

		<li><a name="ssh_client_sftp"></a><span class=text_import1>Linux Client: sftp</span></li>
		<div class=block2>
			那麼如何使用 SSH FTP 的功能呢？也是很容易啦！就是使用
			sftp 這支程式即可！而登入的方式與 ssh 相同，都是使用 sftp -l username hostname
			或者直接以 sftp user@hosname 來書寫！執行之後會有底下的模樣：<br />

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>sftp dmtsai@localhost</span>
Connecting to localhost...
dmtsai@localhost's password: <span class=term_say>&lt;== 這裡請輸入密碼啊！</span>
sftp> <span class=term_say>&lt;== 這裡就是在等待您輸入 ftp 相關指令的地方了！</span>
</pre></td></tr></table>

			進入到 sftp 之後，那就跟在一般 FTP 模式下的操作方法沒有兩樣了！底下我們就來談一談，
			sftp 這個介面下的使用指令吧！<br /><br />

			<table width=90% bgcolor=lightyellow cellspacing=0 cellpadding=5 border=1>
			<tr bgcolor=lightblue><td colspan=2>針對遠方主機(Server)之行為</td></tr>
			<tr><td width=40%>變換目錄到 /etc/test 或其他目錄</td>
				<td><font face="細明體">cd /etc/test<br />cd PATH</font></tr>
			<tr><td>列出目前所在目錄下的檔名</td>
				<td><font face="細明體">ls<br />dir</font></tr>
			<tr><td>建立目錄</td>
				<td><font face="細明體">mkdir directory</font></tr>
			<tr><td>刪除目錄</td>
				<td><font face="細明體">rmdir directory</font></tr>
			<tr><td>顯示目前所在的目錄</td>
				<td><font face="細明體">pwd</font></tr>
			<tr><td>更改檔案或目錄群組</td>
				<td><font face="細明體">chgrp groupname PATH</font></tr>
			<tr><td>更改檔案或目錄擁有者</td>
				<td><font face="細明體">chown username PATH</font></tr>
			<tr><td>更改檔案或目錄的權限</td>
				<td><font face="細明體">chmod 644 PATH<br />其中，644 與權限有關！回去看基礎篇！</font></tr>
			<tr><td>建立連結檔</td>
				<td><font face="細明體">ln oldname newname</font></tr>
			<tr><td>刪除檔案或目錄</td>
				<td><font face="細明體">rm PATH</font></tr>
			<tr><td>更改檔案或目錄名稱</td>
				<td><font face="細明體">rename oldname newname</font></tr>
			<tr><td>離開遠端主機</td>
				<td><font face="細明體">exit (or) bye (or) quit</font></tr>
			<tr bgcolor=lightblue><td colspan=2>針對本機(Client)之行為(都加上 l, L 的小寫 )</td></tr>
			<tr><td>變換目錄到本機的 PATH 當中</td>
				<td><font face="細明體">lcd PATH</font></tr>
			<tr><td>列出目前本機所在目錄下的檔名</td>
				<td><font face="細明體">lls</font></tr>
			<tr><td>在本機建立目錄</td>
				<td><font face="細明體">lmkdir</font></tr>
			<tr><td>顯示目前所在的本機目錄</td>
				<td><font face="細明體">lpwd</font></tr>
			<tr bgcolor=lightblue><td colspan=2>針對資料上傳/下載的行為</td></tr>
			<tr><td>將檔案由本機上傳到遠端主機</td>
				<td><font face="細明體">put [本機目錄或檔案] [遠端]<br />
				put [本機目錄或檔案]<br />
				如果是這種格式，則檔案會放置到目前遠端主機的目錄下！</font></tr>
			<tr><td>將檔案由遠端主機下載回來</td>
				<td><font face="細明體">get [遠端主機目錄或檔案] [本機]<br />
				get [遠端主機目錄或檔案]<br />
				若是這種格式，則檔案會放置在目前本機所在的目錄當中！可以使用萬用字元，例如：<br />
				get *<br />get *.rpm<br />亦是可以的格式！</font></tr>
			</table><br />

			就整體而言， sftp 在 Linux 底下，如果不考慮圖形介面，那麼他已經可以取代
			FTP 了呢！因為所有的功能都已經涵蓋啦！因此，在不考慮到圖形介面的 FTP 軟體時，可以直接關掉
			FTP 的服務，而改以 sftp-server 來提供 FTP 的服務吧！ ^_^<br /><br />
		</div>

		<li><a name="ssh_client_scp"></a><span class=text_import1>Linux Client: scp</span></li>
		<div class=block2>
			如果我要在兩個主機之間複製檔案的話，除了 sftp 之外，還有沒有更簡單的方式？
			有的，那就是利用 scp 這個指令啦！這個指令的用法與 cp 很相像，不過，
			在遠端主機的目錄寫法，比較需要注意就是了。舉例如下：<br />

<table class="term"><tr><td class="term"><pre>
<span class=term_hd>1. 將資料由本機上傳到遠端主機上去</span>
[root@linux ~]# <span class=term_command>scp /etc/crontab dmtsai@localhost:/home/dmtsai/</span>
dmtsai@localhost's password: <span class=term_note>&lt;== 這裡請輸入密碼啊！</span>
crontab                  100%  620     0.6KB/s   00:00
<span class=term_say># 這個例子在說明，我將本機目錄的 /etc/crontab 這個檔案傳送給 dmtsai 
# 這個使用者，而這個使用者是在 "localhost" 那部主機上面喔！
# 仔細看一下，會有一個傳輸資料的訊息跑出來喔！</span>

<span class=term_hd>2. 將資料由遠端主機下載到本機上！</span>
[root@linux ~]# <span class=term_command>scp dmtsai@localhost:~/.bashrc .</span>
<span class=term_say># 這個例子則是在說明，我要將 localhost 那部機器上的 dmtsai 這個人，
# 他家目錄下的 .bashrc 複製到我的機器上！</span>
</pre></td></tr></table>

			也就是說，遠端主機上的檔案或目錄要複製時，是以『 <span class=text_import2>hostname:PATH</span> 』
			方式來書寫的～不要寫錯了呦！而如果想要複製目錄的話，那麼可以加上 -r 的參數！<br /><br />
		</div>

		<li><a name="ssh_client_putty"></a><span class=text_import1>Windows Client: putty</span></li>
		<div class=block2>
			在 Linux 底下想要連接 SSH 伺服器，可以直接利用 <a href="#ssh_client_ssh">ssh</a> 這個指令
			，那麼如果在 Windows 作業系統底下，又該如何連接到 SSH 伺服器呢？可以直接使用
			putty 或 pietty 這種類型的連線軟體呢，他也是免費的自由軟體喔！取得的方式可以參考底下的網站：

			<ul><li>putty 官方網站：<a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/" 
				target="_blank">http://www.chiark.greenend.org.uk/~sgtatham/putty/</a>
			<li>pietty 官方網站：<a href="http://www.csie.ntu.edu.tw/~piaip/pietty/"
				target="_blank">http://www.csie.ntu.edu.tw/~piaip/pietty/</a></ul>

			在 putty 的官方網站上有很多的 client 軟體可以使用的，包括 putty/pscp/psftp 等等。
			他們分別對應了 ssh/scp/sftp 這三個指令就是了。而上述的三個 putty/pscp/psftp 主要是在 Windows
			上面連接到 Unix like 機器的 SSH 伺服器的 Client 軟體呢。請自行下載該軟體喔。<br /><br />

			事實上，鳥哥比較喜歡林弘德先生的 pietty，因為這個軟體不但是完整支援 putty 
			，而且提供的文字編碼較豐富， 實在很好用。在你下載了 pietty 後直接雙擊他，
			會有類似底下的圖示出現。<br /><br />

			<center><img src="0310telnetssh/pietty_01.png"
				title="pietty 的執行圖示之一"
				alt="pietty 的執行圖示之一"><br />
				圖二、pietty 的執行圖示之一</center><br />

			在上圖 1 的地方請填寫相關的主機名稱或者是 IP ，2 當然務必選擇 SSH 那一項，
			至於 3 的地方，鳥哥比較喜歡選單出現的樣式，所以我是選擇選單啦！若沒有問題，按下『連線』後，
			就會出現如下樣式：<br /><br />

			<center><img src="0310telnetssh/pietty_02.png"
				title="pietty 的執行圖示之一"
				alt="pietty 的執行圖示之一"><br />
				圖三、pietty 的執行圖示之一</center><br />

			很像在主機前面工作吧！而且上頭還有選單可以隨時調整類似字形、字體、字元編碼等等。
			尤其是字元編碼。有時候你會發現開啟檔案時，竟然畫面當中會有亂碼而不是正常的中文顯示，
			那就是編碼的問題。要解決這個問題時，你必須要牢記：<br />
			<ul><span class=text_import2>
			<li>文字檔案本身在存檔時所挑選的語系；
			<li>Linux 主機本身所使用的語系 (可用 LANG 變數調整)；
			<li>pietty 所使用的語系。
			</span></ul>
			這三個咚咚的語系要完全相同時才會正確的顯示出中文！千要要牢記啊！
			那如何調整 pietty 的中文編碼呢？<br /><br />

			<center><img src="0310telnetssh/pietty_03.png"
				title="pietty 的執行圖示之一"
				alt="pietty 的執行圖示之一"><br />
				圖四、pietty 的執行圖示之一</center><br />

			在『選項』的『字元編碼』裡面可以挑選 big5 或者是 utf8 的中文編碼，
			讓他符合你的 Linux 與檔案所儲存的資料格式，那就 OK 的啦！ ^_^！
			如果想要作更細部的設定時，可以選擇圖四上頭最底下的那個『詳細設定』項目，
			就會出現如下圖示。其中更為重要的是『鍵盤右側的數字鍵想要生效』時，
			可以按照下圖的指示來啟動數字鍵的功能：<br /><br />

			<center><img src="0310telnetssh/pietty_04.png"
				title="pietty 的執行圖示之一"
				alt="pietty 的執行圖示之一"><br />
				圖五、pietty 的執行圖示之一</center><br />

			如上圖所示，在你輸入『Apply』之後，就可以自動的生效了！現在你可以按鍵盤右邊的按鈕了，
			真方便。再來你可以調整 pietty 捲軸的記憶行數，這樣當資料太多時，你依舊可以調整捲軸來查閱之前的資料。
			設定的方法如下：<br /><br />

			<center><img src="0310telnetssh/pietty_05.png"
				title="pietty 的執行圖示之一"
				alt="pietty 的執行圖示之一"><br />
				圖六、pietty 的執行圖示之一</center><br />

			調整完了螢幕的大小之後，再來這是最重要的：『您要以哪一個版本的 SSH
			演算法登入？！』前面說過，我們預設是以 version2 來登入的，所以這裡我們可以調整為
			2 那個項目！這樣每次登入都會以 version 2 的模式登入主機了！<br /><br />

			<center><img src="0310telnetssh/pietty_06.png"
				title="pietty 的執行圖示之一"
				alt="pietty 的執行圖示之一"><br />
				圖七、pietty 的執行圖示之一</center><br />

			整個 pietty 大致上的流程就是這樣！如此一來，您就可以在 Windows 上面以
			SSH 的協定，登入遠端的 Linux 主機嚕！粉方便吧！ ^_^ ！
			那麼如果想要中文支援的話，目前
			pietty 已經支援中文啦！您可以輸入中文喔！不過需要修改一下字元集，
			選擇圖四的『選項』內的『字型』，會出現如下圖示：<br /><br />

			<center><img src="0310telnetssh/pietty_07.png"
				title="pietty 的執行圖示之一"
				alt="pietty 的執行圖示之一"><br />
				圖八、pietty 的執行圖示之一</center><br />

			<span class=text_import2>將(1)字型設定為細明體
			(2)字集設定為『Big5』，如此一來，您的 pietty 就支援中文的輸入囉！</span> ^_^<br />

			那麼上面我們作的這些設定值都記錄在哪裡啊？呵呵！都記錄在 Windows 的登錄檔當中啊！
			您可以在 Windows 的系統當中，在『開始』-->『執行』後，出現的框框內輸入『regedit』，
			之後會出現一個大視窗。請在左邊的畫面當中選擇『<span class=text_import1>
			HKEY_CURRENT_USER --> Software --> SimonTatham --> PuTTY --> Sessions</span>』，
			就可以看到您的設定值囉！ ^_^！ 這樣，也就可以儲存您的設定值囉～<br /><br />
		</div>

		<li><a name="ssh_client_psftp"></a><span class=text_import1>Windows Client: psftp</span></li>
		<div class=block2>
			在 putty 的官方網站上也提供 psftp 這支程式。這一支程式的重點則是在於以 sftp 
			連線上 Server 。連線的方式可以直接點選
			psftp 這個檔案，讓他直接啟動，則會出現下面的圖樣：<br />

<table class="term"><tr><td class="term"><pre>
psftp: no hostname specified; use "open host.name" to connect
psftp>
</pre></td></tr></table>

			這個時候可以填入您要連接上去的主機名稱，例如我的區域內網路 linux.dmtsai.tw 這個主機<br />

<table class="term"><tr><td class="term"><pre>
psftp: no hostname specified; use "open host.name" to connect
psftp> <span class=term_command>open test.linux.org</span>
login as: <span class=term_command>dmtsai</span>
Using username "dmtsai".
dmtsai@linux.dmtsai.tw's password:
Remote working directory is /home/dmtsai
psftp> <span class=term_say>&lt;== 這裡就在等待您輸入 FTP 的指令了！</span>
</pre></td></tr></table>

			呵呵！這樣就登入主機啦！很簡單吧！然後其他的使用方式跟前面提到的 sftp 一樣哩！加油的使用吧！<br /><br />
		</div>

		<li><a name="ssh_client_filezilla"></a><span class=text_import1>Windows Client: Fliezilla</span></li>
		<div class=block2>
		那麼 SSH 所提供的 sftp 功能只能利用純文字介面的 psftp 來連線嗎？有沒有圖形介面的軟體呢？呵呵！當然有！
		那就是非常有用的 Filezilla 囉！Filezilla 是圖形介面的一個 FTP 用戶端軟體，使用上非常的方便，
		至於詳細的安裝與使用流程請參考 <a href="0410vsftpd.htm#client">vsftpd</a> 章節的說明喔！<br />
		</div>
	</div>

	<hr /><a name="ssh_sshdconfig"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class=text_h2>詳細設定 sshd 伺服器</span><br />
	<div class=block2>
		基本上，所有的 ssh 相關設定都放在 <span class=text_import2>/etc/ssh/sshd_config</span> 
		裡面！不過，每個 Linux distribution 的預設設定都不太相同，
		所以我們有必要來瞭解一下整個設定值的意義為何才好！<br />

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>vi /etc/ssh/sshd_config</span>
<span class=term_hd># 1. 關於 SSH Server 的整體設定，包含使用的 port 啦，以及使用的密碼演算方式</span>
<span class=term_say># 先留意一下，在預設的檔案內，只要是被註解的設定值(#)，即為『預設值！』</span>
<span class=term_write>Port 22</span>
<span class=term_say># SSH 預設使用 22 這個port，也可以使用多個port，即重複使用 port 這個設定項目！
# 例如想要開放 sshd 在 22 與 443 ，則多加一行內容為：
# Port 443 
# 這樣就好了！不過，不建議修改 port number 啦！</span>

<span class=term_write>Protocol 1,2</span>
<span class=term_say># 選擇的 SSH 協定版本，可以是 1 也可以是 2 ，
# 如果要同時支援兩者，就必須要使用 2,1 這個分隔了(Protocol 1,2)！
# 目前我們會建議您，直接使用 Protocol 2 即可！</span>

<span class=term_write>#ListenAddress 0.0.0.0</span>
<span class=term_say># 監聽的主機介面卡！舉個例子來說，如果您有兩個 IP，
# 分別是 192.168.0.100 及 192.168.2.20 ，那麼只想要
# 開放 192.168.0.100 時，就可以寫如同下面的樣式：</span>
<span class=term_write>ListenAddress 192.168.0.100</span>
<span class=term_say># 只監聽來自 192.168.0.100 這個 IP 的SSH連線。
# 如果不使用設定的話，則預設所有介面均接受 SSH</span>

<span class=term_write>#PidFile /var/run/sshd.pid</span>
<span class=term_say># 可以放置 SSHD 這個 PID 的檔案！左列為預設值</span>

<span class=term_write>#LoginGraceTime 2m</span>
<span class=term_say># 當使用者連上 SSH server 之後，會出現輸入密碼的畫面，在該畫面中，
# 在多久時間內沒有成功連上 SSH server ，就斷線！若無單位則預設時間為秒！</span>

<span class=term_write>#Compression yes</span>
<span class=term_say># 是否可以使用壓縮指令？當然可以囉</span>

<span class=term_hd># 2. 說明主機的 Private Key 放置的檔案，預設使用下面的檔案即可！</span>
<span class=term_write>#HostKey /etc/ssh/ssh_host_key</span>        <span class=term_say># SSH version 1 使用的私鑰</span>
<span class=term_write>#HostKey /etc/ssh/ssh_host_rsa_key</span>    <span class=term_say># SSH version 2 使用的 RSA 私鑰</span>
<span class=term_write>#HostKey /etc/ssh/ssh_host_dsa_key</span>    <span class=term_say># SSH version 2 使用的 DSA 私鑰
# 還記得我們在主機的 SSH 連線流程裡面談到的，這裡就是 Host Key ～</span>

<span class=term_hd># 2.1 關於 version 1 的一些設定！</span>
<span class=term_write>#KeyRegenerationInterval 1h</span>
<span class=term_say># 由前面連線的說明可以知道， version 1 會使用 server 的 Public Key ，
# 那麼如果這個 Public Key 被偷的話，豈不完蛋？所以需要每隔一段時間
# 來重新建立一次！這裡的時間為秒！不過我們通常都僅使用 version 2 ，
# 所以這個設定可以被忽略喔！</span>

<span class=term_write>#ServerKeyBits 768</span>
<span class=term_say># 沒錯！這個就是 Server key 的長度！用預設值即可。</span>

<span class=term_hd># 3. 關於登錄檔的訊息資料放置與 daemon 的名稱！</span>
<span class=term_write>SyslogFacility AUTHPRIV</span>
<span class=term_say># 當有人使用 SSH 登入系統的時候，SSH會記錄資訊，這個資訊要記錄在什麼 daemon name
# 底下？預設是以 AUTH 來設定的，即是 /var/log/secure 裡面！什麼？忘記了！
# 回到 <a href="../linux_basic/">Linux 基礎</a> 去翻一下。其他可用的 daemon name 為：DAEMON,USER,AUTH,
# LOCAL0,LOCAL1,LOCAL2,LOCAL3,LOCAL4,LOCAL5,</span>

<span class=term_write>#LogLevel INFO</span>
<span class=term_say># 登錄記錄的等級！嘿嘿！任何訊息！同樣的，忘記了就回去參考！</span>

<span class=term_hd># 4. 安全設定項目！極重要！
# 4.1 登入設定部分</span>
<span class=term_write>PermitRootLogin no</span>
<span class=term_say># 是否允許 root 登入！預設是允許的，但是<span class=term_note_b>建議設定成 no！</span></span>

<span class=term_write>#UserLogin no</span>
<span class=term_say># 在 SSH 底下本來就不接受 login 這個程式的登入！</span>

<span class=term_write>#StrictModes yes</span>
<span class=term_say># 當使用者的 host key 改變之後，Server 就不接受連線，可以抵擋部分的木馬程式！</span>

<span class=term_write>#RSAAuthentication yes</span>    <span class=term_say># 是否使用純的 RSA 認證！？僅針對 version 1 ！</span>
<span class=term_write>#PubkeyAuthentication yes</span> <span class=term_say># 是否允許 Public Key ？當然允許啦！僅針對 version 2</span>
<a name="sshd_config_auth"></a>
<span class=term_write>#AuthorizedKeysFile      .ssh/authorized_keys</span>
<span class=term_say># 上面這個在設定若要使用不需要密碼登入的帳號時，那麼那個帳號的存放檔案所在檔名！
# 這個設定值很重要喔！檔名給他記一下！</span>

<span class=term_hd># 4.2 認證部分</span>
<span class=term_write>#RhostsAuthentication no</span>
<span class=term_say># 本機系統不使用 .rhosts，因為僅使用 .rhosts太不安全了，所以這裡一定要設定為 no</span>

<span class=term_write>#IgnoreRhosts yes</span>
<span class=term_say># 是否取消使用 ~/.ssh/.rhosts 來做為認證！當然是！</span>

<span class=term_write>#RhostsRSAAuthentication no #</span>
<span class=term_say># 這個選項是專門給 version 1 用的，使用 rhosts 檔案在 /etc/hosts.equiv
# 配合 RSA 演算方式來進行認證！不要使用啊！</span>

<span class=term_write>#HostbasedAuthentication no</span>
<span class=term_say># 這個項目與上面的項目類似，不過是給 version 2 使用的！</span>

<span class=term_write>#IgnoreUserKnownHosts no</span>
<span class=term_say># 是否忽略家目錄內的 ~/.ssh/known_hosts 這個檔案所記錄的主機內容？
# 當然不要忽略，所以這裡就是 no 啦！</span>

<span class=term_write>PasswordAuthentication yes</span>
<span class=term_say># 密碼驗證當然是需要的！所以這裡寫 yes 囉！</span>

<span class=term_write>#PermitEmptyPasswords no</span>
<span class=term_say># 若上面那一項如果設定為 yes 的話，這一項就最好設定為 no ，
# 這個項目在是否允許以空的密碼登入！當然不許！</span>

<span class=term_write>ChallengeResponseAuthentication no</span>
<span class=term_say># 允許任何的密碼認證！所以，任何 login.conf 規定的認證方式，均可適用！
# 但目前我們比較喜歡使用 PAM 模組幫忙管理認證，因此這個選項可以設定為 no 喔！</span>
<span class=term_write>UsePAM yes</span>
<span class=term_say># 利用 PAM 管理使用者認證有很多好處，可以記錄與管理。
# 所以這裡我們建議您使用 UsePAM 且 ChallengeResponseAuthentication 設定為 no </span>
　
<span class=term_hd># 4.3 與 Kerberos 有關的參數設定！因為我們沒有 Kerberos 主機，所以底下不用設定！</span>
<span class=term_write>#KerberosAuthentication no
#KerberosOrLocalPasswd yes
#KerberosTicketCleanup yes
#KerberosTgtPassing no</span>
　
<span class=term_hd># 4.4 底下是有關在 X-Window 底下使用的相關設定！</span>
<span class=term_write>X11Forwarding yes
#X11DisplayOffset 10
#X11UseLocalhost yes</span>

<span class=term_hd># 4.5 登入後的項目：</span>
<span class=term_write>PrintMotd no</span>
<span class=term_say># 登入後是否顯示出一些資訊呢？例如上次登入的時間、地點等等，預設是 yes
# 亦即是列印出 /etc/motd 這個檔案的內容。但是，如果為了安全，可以考慮改為 no ！</span>

<span class=term_write>PrintLastLog yes</span>
<span class=term_say># 顯示上次登入的資訊！可以啊！預設也是 yes ！</span>

<span class=term_write>KeepAlive yes</span>
<span class=term_say># 一般而言，如果設定這項目的話，那麼 SSH Server 會傳送KeepAlive 的訊息給 
# Client端，以確保兩者的連線正常！在這個情況下，任何一端死掉後，SSH可以立刻知道！
# 而不會有僵屍程序的發生！</span>

<span class=term_write>UsePrivilegeSeparation yes</span>
<span class=term_say># 使用者的權限設定項目！就設定為 yes 吧！</span>

<span class=term_write>MaxStartups 10</span>
<span class=term_say># 同時允許幾個尚未登入的連線畫面？當我們連上 SSH ，但是尚未輸入密碼時，
# 這個時候就是我們所謂的連線畫面啦！在這個連線畫面中，為了保護主機，
# 所以需要設定最大值，預設最多十個連線畫面，而已經建立連線的不計算在這十個當中</span>

<span class=term_hd># 4.6 關於使用者抵擋的設定項目：</span>
<span class=term_write>DenyUsers *</span>
<span class=term_say># 設定受抵擋的使用者名稱，如果是全部的使用者，那就是全部擋吧！
# 若是部分使用者，可以將該帳號填入！例如下列！</span>
<span class=term_write>DenyUsers test

DenyGroups test</span>
<span class=term_say># 與 DenyUsers 相同！僅抵擋幾個群組而已！</span>

<span class=term_hd># 5. 關於 SFTP 服務的設定項目！</span>
<span class=term_write>Subsystem       sftp    /usr/lib/ssh/sftp-server</span>
</pre></td></tr></table>

		基本上，CentOS 預設的 sshd 服務已經算是挺安全的了，不過還不夠！
		<span class=text_import2>建議你 (1)將 root 的登入權限取消； (2)將 ssh 版本設定為 2 </span>。
		其他的設定值就請您依照自己的喜好來設定了。通常不建議進行隨便修改啦！
		另外，如果您修改過上面這個檔案(/etc/ssh/sshd_config)，那麼就必需要重新啟動一次
		sshd 這個 daemon 才行！亦即是：
		<ul><li><span class=text_import2><font face="細明體">/etc/init.d/sshd restart</font></span></li></ul>
	</div>

	<hr /><a name="ssh_nopasswd"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class=text_h2>製作不用密碼可立即登入的 ssh 用戶：</span><br />
	<div class=block2>
		咦！既然 SSH 可以使用 Key 來比對資料，並且提供使用者資料的加密功能，
		那麼可不可能利用這個 Key 就提供使用者自己進入主機，而不需要輸入密碼呢？
		呵呵！好主意！我們可以將 Client 產生的 Key 給他拷貝到 Server 當中，所以，
		以後 Client 登入 Server 時，由於兩者在 SSH 要連線的訊號傳遞中，就已經比對過 Key 了，
		因此，可以立即進入資料傳輸介面中，而不需要再輸入密碼呢！在實作上的步驟可以是：

		<ol><span class=text_import2>
		<li>首先，先在 Client 上面建立 Public Key 跟 Private Key 這兩把鑰匙，利用的指令為 
			ssh-keygen 這個命令；
		<li>再來，將 Private Key 放在 Client 上面的家目錄，亦即 $HOME/.ssh/ ，
			並且修改權限為僅有該 User 可讀的狀態；
		<li>最後，將那把 Public Key 放在任何一個您想要用來登入的主機的 Server 端的某 
			User 的家目錄內之 .ssh/ 裡面的認證檔案即可完成整個程序。</span></ol>

		說是好像很困難的樣子，其實步驟真的很簡單，我們依序來進行作業好了！假設前提：

		<ul>
		<li>Server 部分為 linux.dmtsai.tw 這部 192.168.0.2 的主機，欲使用的 User 為 test 這個帳號；
		<li>Client 部分為 test2.dmtsai.tw 這部 192.168.0.100  PC 的 test2 這個帳號，
			他要用來登入 192.168.0.2 這部主機的 test 這個帳號。
		</ul>

		<ol>
		<li><span class=text_import1>在 Client 端建立 Public 與 Private Key ：</span></li><br />
			建立的方法真的是簡單到不行！直接在 192.168.0.100 這個 Client 上面，以
			test2 這個帳號，使用 ssh-keygen 這個指令來進行 Key 的產生即可！不過，需要注意的是，
			version 1 與 version 2 使用的密碼演算方式不同，此外， version 2 
			提供兩個密碼演算的方法，我們這裡僅針對 version 2 的 RSA 這個演算方法進行說明！<br />

<table class="term"><tr><td class="term"><pre>
[test2@test2 ~]$ <span class=term_command>ssh-keygen -t rsa</span>  <span class=term_say>&lt;==這個步驟在產生 Key pair</span>
Generating public/private rsa key pair.
Enter file in which to save the key (/home/test2/.ssh/id_rsa): <span class=term_say>&lt;==這裡按下Enter</span>
Enter passphrase (empty for no passphrase): <span class=term_say>&lt;==這裡按 Enter</span>
Enter same passphrase again:  <span class=term_say>&lt;==再按一次 Enter</span>
<span class=term_write>Your identification has been saved in /home/test2/.ssh/id_rsa. <span class=term_say>&lt;==這是私鑰</span>
Your public key has been saved in /home/test2/.ssh/id_rsa.pub. <span class=term_say>&lt;==這是公鑰</span></span>
The key fingerprint is:
c4:ae:d9:02:d1:ba:06:5d:07:e6:92:e6:6a:c8:14:ba test2@test2.linux.org
<span class=term_say># 注意： -t 指的是『使用何種密碼演算方式？』由於我們使用 RSA ，
# 所以直接輸入 -t rsa 即可建立兩支 Keys ！
# 此外，建立的兩把 Keys 都放置在家目錄下的 .ssh 這個目錄中！
# 察看一下這兩把 Keys 吧！</span>

[test2@test2 ~]$ <span class=term_command>ll ~/.ssh</span>
total 12
-rw-------    1 test2    test2         887 Nov 12 22:36 id_rsa
-rw-r--r--    1 test2    test2         233 Nov 12 22:36 id_rsa.pub
-rw-r--r--    1 test2    test2         222 Oct 31 11:20 known_hosts
</pre></td></tr></table>

			請注意上面喔，我的身份是 test2 ，所以當我執行 ssh-keygen 時，
			才會在我的家目錄底下的 .ssh/ 這個目錄裡面產生所需要的兩把 Keys 
			，分別是<span class=text_import2>私鑰(id_rsa)與公鑰(id_rsa.pub)</span>。另外一個要特別注意的就是那個 
			id_rsa 的檔案權限啦！他必須要是 <span class=text_import2>-rw-------</span> 
			才好！否則內容被人家知道了，那麼您的 Keys 不就有可能外洩了？所以請特別留意他的權限喔！
			<span class=text_import2>那麼那個 id_rsa.pub 則是『公鑰！』這個檔案必須要被放置到 Server 端才行！</span>
			<br /><br />

		<li><span class=text_import1>在 Client 端放置私鑰：</span></li><br />
			在預設的條件中，我們的私鑰必需要放置在家目錄底下的 .ssh 裡面，那麼如果是
			version 2 的 RSA 演算法，就需要放置在 $HOME/.ssh/id_rsa 當中！咦！剛好使用
			ssh-keygen 就是已經產生在這個目錄下了，所以自然就不需要去調整他了！以我的
			test2.dmtsai.tw 來看，那麼我的檔案就會放置在 /home/test2/.ssh/id_rsa 這個檔案就是私鑰啦！<br /><br />

		<li><span class=text_import1>在 Server 端放置可以登入的公鑰：</span></li><br />
			既然我們要讓 test2 可以用 test 這個帳號登入 linux.dmtsai.tw 這部主機，那麼這部主機自然需要保有
			test2 的 public key 囉！對的！所以我們必需要將 Client 端建立的 id_rsa.pub
			檔案給他拷貝到 linux.dmtsai.tw 裡頭的 test 這個使用者的家目錄之下！那麼如果您還記得上面的
			<a href="#sshd_config_auth">sshd_config</a> 這個檔案的設定的話，那麼應該就記得『
			<span class=text_import1>AuthorizedKeysFile</span> 』這個設定吧！是的！
			在被登入的主機的某個帳號，他的公鑰放置的檔案名稱預設就是這個項目所記載的！而他預設的檔名就是
			<span class=text_import1>authorized_keys</span>
			這個檔案名稱啦！那麼應該怎麼做呢？<br />

<table class="term"><tr><td class="term"><pre>
<span class=term_hd>1. 先在 Client 端以 sftp 將公鑰丟到 test 上面去！</span>
[test2@test2 ~]$ <span class=term_command>cd ~/.ssh</span>
[test2@test2 .ssh]$ <span class=term_command>scp id_rsa.pub test@192.168.0.2:~/</span>
test@192.168.0.2's password:
id_rsa.pub          100%  233     0.2KB/s   00:00

<span class=term_hd>2. 到 Server 上面，將公鑰轉存到 authorized_keys 檔案中！</span>
[test@linux ~]$ <span class=term_command>cd ~/.ssh</span>
[test@linux .ssh]$ <span class=term_command>cat ../id_rsa.pub >> authorized_keys</span>
</pre></td></tr></table>

			請注意上面的機器！由於 authorized_keys 可以保存相當多的公鑰內容，因此，
			可以使用 >> 的方式來將 Client 端的公鑰新增到該檔案內！呵呵！做完這一步一後，未來 
			test2 就可以直接在 test2.dmtsai.tw 以<br />

<table class="term"><tr><td class="term"><pre>
[test2@test2 ~]$ <span class=term_command>ssh test@linux.dmtsai.tw</span>
</pre></td></tr></table>

			這樣就可以不需要輸入密碼囉！但是請注意， test 不能以 test2 登入 test2.linux.org 喔！
		</ol>

		很簡單的步驟吧！這樣一來，就可以不需密碼的手續了！無論如何，您要記得的是：<br />
		<ul><span class=text_import2>
		<li>Client 必須製作出 Public & Private 這兩把 keys，且 Private 需放到 ~/.ssh/ 內；
		<li>Server 必須要有 Public Key ，且放置到使用者家目錄下的 ~/.ssh/authorized_keys；
		</span></ul>

		未來，當您還想要登入其他的主機時，只要將您的 public key (就是 id_rsa.pub 這個檔案) 給他 
		copy 到其他主機上面去，並且新增到某帳號的 ~/.ssh/authorized_keys 這個檔案中！哈哈！成功！<br /><br />
	</div>

	<hr /><a name="ssh_secure"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class=text_h2>安全設定：</span><br />
	<div class=block2>
		老實說，大家都被『<span class=text_import2>SSH 是個安全的服務』所欺騙了</span>！其實
		sshd 並不怎麼安全的！翻開 openssh 的過去歷史來看，確實有很多人是利用 ssh 的程式漏洞來取得遠端主機 root 
		的權限，進一步黑掉對方的主機！<br /><br />

		sshd 之所謂的『安全』其實指的是『
		<span class=text_import2>sshd 的資料是加密過的，所以他的資料在 Internet 上面傳遞時是比較安全的。</span>
		至於 sshd 這個服務本身就不是那樣安全了！所以說：『<span class=text_import2>非必要，不要將 sshd 對
		Internet 開放可登入的權限，盡量侷限在幾個小範圍內的 IP 或主機名稱即可！</span>
		這很重要的喔！<br /><br />



		好了，那麼關於安全的設定方面，有沒有什麼值得注意的呢？當然是有啦！
		我們可以先建議幾個項目吧！分別可以由：

		<ul><span class=text_import2>
		<li>/etc/ssh/sshd_config
		<li>/etc/hosts.allow, /etc/hosts.deny
		<li>iptables</ul></span>

		這三方面來著手進行！底下我們就說一說吧！<br /><br />

		<li><span class=text_import1>/etc/ssh/sshd_config</span></li>
		<div class=block2>
			一般而言，這個檔案的預設項目就已經很完備了！所以，事實上是不太需要更動他的！
			但是，如果您有些使用者方面的顧慮，那麼可以這樣修正一些問題呢！

			<ul>
			<li><span class=text_import2>禁止 root 的登入</span>：<br />
			任何時候，不許 root 以遠端連線的方式登入，都會是一個好主意！所以這裡蠻建議大家直接將
			root 的登入權限拿掉吧！所以，可以修改 /etc/ssh/sshd_config 這個檔案的內容為：<br />

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>vi /etc/ssh/sshd_config</span>
<span class=term_write>PermitRootLogin no</span>     <span class=term_say>&lt;== 將他改成 no 吧！</span>
[root@linux ~]# <span class=term_command>/etc/init.d/sshd restart</span>
</pre></td></tr></table>

			如此一來，以後 root 就不能以 ssh 登入囉！這樣還是比較好的啦！ ^_^<br /><br />

			<li><span class=text_import2>不許某個群組登入</span>：<br />
			有些特殊情況中，我們想要讓使用者只能使用
			sendmail, pop3, ftp 等，但是不希望他可以遠端連線進來，那麼您可以這樣做：<br /><br />

			1. 將這些使用者都歸納在某一個特殊群組之下，例如 nossh 這個群組好了；<br />
			2. 在 /etc/ssh/sshd_config 當中加入這一行：『
				<span class=text_import2>DenyGroups&nbsp;&nbsp;nossh</span> 』<br />
			3. 重新啟動 sshd ： <font face="細明體">/etc/init.d/sshd restart</font><br /><br />

			這樣就OK啦！<br /><br />

			<li><span class=text_import2>不許某個使用者登入</span>：<br />
			跟 DenyGroups 類似，使用 DenyUsers 即可！參考 <a href="#ssh_sshdconfig">sshd_config</a> 的設定喔！
			</ul>
		</div>

		<li><span class=text_import1>/etc/hosts.allow 及 /etc/hosts.deny</span></li>
		<div class=block2>
			簡單的方法就是：<br />

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>vi /etc/hosts.allow</span>
sshd: 192.168.0.1, 192.168.0.2, 192.168.0.3, 192.168.0.4, 192.168.0.5: allow

[root@linux ~]# <span class=term_command>vi /etc/hosts.deny</span>
sshd : ALL : spawn (/bin/echo Security notice from host `/bin/hostname`; \ 
/bin/echo; /usr/sbin/safe_finger @%h ) | \ 
/bin/mail -s "%d -%h security" root@localhost & \ 
: twist ( /bin/echo -e "\n\nWARNING connectin not allowed.". ) 
</pre></td></tr></table>
		</div>

		<li><span class=text_import1>iptables</span></li>
		<div class=block2>
			多幾層保護也很好的！所以也可以使用 iptables 喔！參考：
			<a href="0250simple_firewall.htm">簡易防火牆架設</a> 一文囉！
		</div>

		最後，『<span class=text_import1>鳥哥呼籲大家，不要開放 SSH 的登入權限給所有 Internet 上面的主機～</span>』
		這很重要喔～因為如果對方可以 ssh 進入您的主機，那麼......太危險了～
	</div>
</div>

<hr /><a NAME="xdmcp"></a><img src="/images/penguin-m.gif" alt="大標題的圖示" height="34" width="25" align="middle" /><span class="text_h1">XDMCP 伺服器</span><br />
<div class=block1>
	考慮一個情況，如果您的 Linux 主機上面主要是用來作為圖形處理時，而且同時有多人需要用到那個功能，
	那麼一部 Linux 是否一次僅能提供一個人處理那個軟體呢？嘿嘿！那可不一定喔！因為 Linux 
	有相當優秀的 X Window System 啊！<br /><br />

	<hr /><a name="xdmcp_theory"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class=text_h2>X Window 的 Server/Client 架構</span><br />
	<div class=block2>
		X Window System 的架構對於常常玩網路的朋友來說(這也包括鳥哥啦！ @_@)實在不太好理解～
		因為 X Window System 在運作的過程中，同樣包含了 X Server 與 X Client 這兩個東西，
		但是他的作用卻與網路主機的 Server/Client 架構大異其趣喔～先來說說 X Server/Client 所負責的東西：

		<ul>
		<li><span class=text_import2>X Server： 他主要負責的是螢幕畫面的繪製與顯示</span>。
			X Server 可以接收來自 X client 的數據，
			將這些數據繪製呈現為圖面在螢幕上。此外，我們移動滑鼠、點擊資料、由鍵盤輸入資料等等，
			也會透過 X Server 來傳達到 X Client 端，而由 X Client 來加以運算；</li><br />
		<li><span class=text_import2>X Client： 他主要負責的是資料的運算。</span>
			X Client 在接受到 X Server 傳來的資料後，會經由本身的運算，而得到滑鼠應該要如何移動、
			點擊的結果應該要出現什麼樣的資料、鍵盤輸入的結果應該要如何呈現等等，
			然後將這些結果告知 X Server ，讓他自行去繪製到螢幕上。</li></ul>

		這樣說可以理解嗎？也就是說，我們移動滑鼠或敲打鍵盤時， X server 可以接受到這些硬體所輸入的資料，
		但他不知道應該要怎麼作才好，就把這些資料告訴 X Client ，此時， X Client 就會將這些資料計算，
		最後得到滑鼠應該要如何移動與鍵盤的資料應該要如何呈現，並將這些結果告知 X Server ，
		而 X Server 就會經由 X Client 的告知，而將那些數據資料在螢幕上面呈現出來。<br /><br />

		事實上， X Server 與 X Client 通常是在同一部機器上面的，
		例如我們在 Linux 上面執行有名的 KDE 這個桌面一樣。
		但是 X Server/Client 卻不必然一定要在同一部機器上的，
		也就是說，我們可以透過網路連接兩部主機的 X 系統呢！
		這也是最早 X 系統開發時的概念。不過，這個時候的 X server 指的是哪一部呢？<br /><br />

		舉個例子來說，我們可以在 Windows 系統上面執行一套 X Win32 的軟體，
		他可以連接到 Linux 的 X 上頭而讓使用者以圖形介面登入 Linux 。
		此時，因為『X Win 32』主要是在螢幕上面顯示，他的做用就是螢幕繪製，因此他是 X Server 。
		不信的話，等一下我們測試底下的資料時，您會發現，啟動 X win32 這套軟體後，
		在 Windows 系統上就會出現 port 6000 這個 X server 的 port 呢～而這個時候 X Win 32 
		軟體其實就是連接到 Linux 的某個程序，我們等一下要介紹的 XDMCP 就是其中一種。
		這個 XDMCP 可以將 X Win32 傳送過來的資料運算成可以繪製的數據而回傳給 X win 32 那套軟體，
		此時的 XDMCP 程序就是一個 X Client 囉～<br /><br />

		所以啦！如果您的 Windows 想要連接到 Linux 主機的話，那麼 Windows 就得要有可以執行的 X Server 軟體啦～
		而 Linux 主機則必須要啟動一個可以接受 X Server 資料運算的 X Client 啦～
		就是這樣說～<br /><br />

		但是，這樣做有什麼好處呢？呵呵～最大的好處就是，<span class=text_import2>在伺服器上的 X Client 不需要知道 
		X Server 的硬體是什麼～</span>因為負責顯示的是 X server 的事情，管理硬體的動作也是 X server 在做，
		在主機上的 X Client 只是將這些滑鼠移動與點擊還有鍵盤的輸入等的資料在主機端運算後，
		最後將結果傳送給 X Server 顯示而已。(當然啦， 
		X Client 的運算內容還是會用到主機端的設定檔與函式庫就是了。)<br /><br />

		<center>
		<img src="0310telnetssh/Xserver_client.png" border=1
		title="X server/client 的架構" alt="X server/client 的架構"><br />
		圖九、X server/client 的架構</center><br />

		那麼什麼時候會出現多使用者連入 X 主機的情況呢？以鳥哥的例子來說，我們實驗室有一部 Linux 在進行數值模擬，
		他輸出的結果是 NetCDF 檔案，我們必須使用 PAVE 這一套軟體去處理這些資料，
		以繪製等濃度圖等等的。但是我們有兩三個人同時都會使用到那個功能，
		偏偏 Linux 主機是放在機架櫃裡面的，要我們擠在那個小小的空間前面『站著』操作電腦，
		可真是討人厭啊～這個時候，我們就會架設圖形介面的遠端登入伺服器，
		讓我們可以『<span class=text_import2>多人同時以圖形介面登入 Linux 主機</span>』來操作我們自己的程序！
		很棒，不是嗎？！<br /><br />
	</div>

	<hr /><a name="xdmcp_setup"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class=text_h2>設定 XDMCP</span><br />
	<div class=block2>
		XDM 是 X Display Manager 的簡稱，他的功能是什麼呢？
		簡單的說，就是管理操控 X Server 的顯示啦～他主要有兩種管理方式，
		如果 X Server/Client 在同一部機器上，那麼啟動 xdm 之後，就會產生一個 X server 了；
		而如果 X server/client 不在同一部主機上面，那麼啟動 xdm 後，他就會透過網路去管理遠端那部主機的 
		X server 了。而 XDMCP (X Display Manager Control Protocol) 就是負責監聽來自網路上面對於 
		xdm 的要求的啦～<br /><br />

		由 X11 (CentOS 使用的是 Xorg 這個計畫的 X11)提供的 display manager 為 xdm ，設定檔在 
		<span class=text_import2>/etc/X11/xdm/xdm-config</span> ，
		而著名的 KDE 與 GNOME 也都有自己的 display manager 管理程序，分別是 kdm 與 gdm ，
		設定檔則是 <span class=text_import2>/etc/X11/xdm/kdmrc 與 /etc/X11/gdm/gdm.conf</span>
		(不同的 distribution 這個檔案放置的目錄不太一樣)。我們可以透過三者中任何一者的 display manager 
		的設定檔來啟動 xdmcp 這個協定呢～<br /><br />

		要啟用 xdmcp 的功能真的很簡單，如果您要啟用 xdm 的話，修改 /etc/X11/xdm/xdm-config 這個檔案，
		找到底下這一行(一般在最後一行)：<br />

<table class="term"><tr><td class="term"><pre>
DisplayManager.requestPort:    0
</pre></td></tr></table>

		將他修改成為：<br />

<table class="term"><tr><td class="term"><pre>
<span class=term_write>!</span>DisplayManager.requestPort:    0
</pre></td></tr></table>

		亦即是註解掉，然後再重新啟動 xdm 就好了。而 kdm 與 gdm 的設定也類似，底下鳥哥主要以 kdm 
		來進行 xdmcp 的架設。不過要注意的是，即使在 Linux 主機端不啟用 X Server (port 6000) 
		也是可以正確無誤的提供 X 介面的登入的～就如同上面提到的概念一般～
		但是，如果要獲得比較正確的訊息，那麼還是建議您，<span class=text_import2>啟用 kdm 時一併正確的啟動 X </span>，
		只是安全性上面就要注意一些了！好了，多說無益，來實作吧！<br />

<table class="term"><tr><td class="term"><pre>
<span class=term_hd>1. 先讓 kdm 支援 xdmcp 模式</span>
[root@linux ~]# <span class=term_command>cd /etc/X11/xdm</span>
[root@linux xdm]# <span class=term_command>vi kdmrc</span>
<span class=term_write>[Xdmcp]
Enable=1</span>
<span class=term_say># 大約是在 70 行左右。不要懷疑！真的只要這樣就好了！</span>

<span class=term_hd>2. 讓 client 可以透過 X 來登入系統！與權限有關的設定</span>
[root@linux xdm]# <span class=term_command>vi Xaccess</span>
<span class=term_write>*</span>
<span class=term_say># 為了安全性上面的需要，想要登入 X 的話，得要通過這個檔案的驗證才行。
# 找到上面這一行，如果沒有這一行的話(整行只有一個 * )，
# 就自行加入。這表示『不論來自哪裡，我都接受 X 登入』的意思！</span>

<span class=term_hd>3. 啟動 kdm 喔！</span>
[root@linux xdm]# <span class=term_command>/etc/init.d/xfs start</span>
<span class=term_say># 就如同我們上面提到的， kdm 執行後，可能的話，會在本機端啟動一個 X server 的，
# 而我們這一版的 Xorg 要順利的啟動，得要先啟用 X font Server 才行，
# 否則的話，您就得要到 /etc/X11/Xorg.conf 裡面去設定好每個字型的路徑才行。</span>
[root@linux xdm]# <span class=term_command>kdm</span>
[root@linux xdm]# <span class=term_command>netstat -tlunp</span>
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address  Foreign Address  State  PID/Program name
tcp        0      0 0.0.0.0:<span class=term_write>6000</span>   0.0.0.0:*        LISTEN 5920/X
tcp        0      0 :::6000        :::*             LISTEN 5920/X
udp        0      0 :::<span class=term_write>177</span>         :::*                    5918/kdm
<span class=term_say># 要看到有 177 的 udp port 出現才行～ 因為那是 xdmcp 協定的監聽埠口。
# 不過，如果要看看是否有成功啟動 X 的話，就得要查閱 6000 這個 port 囉～
# 如果沒有看到 port 6000 的話，請查閱 /var/log/Xorg.0.log 喔！
# 如果想要設定開機就自動執行的話，可以利用 chkconfig 加入 xfs ，
# 也可以將 kdm 這個指令寫到 /etc/rc.d/rc.local 這個檔案中～</span>
</pre></td></tr></table>

	雖然是非必備的，不過為了避免困擾，這裡還是得要提醒大家。(因為 CentOS 不需要啟動 X 就能夠提供 xdmcp 登入)
	鳥哥上面的測試是在 run level 為 3 的環境下，且整體在執行的時候，
	/var/log/messages 與 /var/log/Xorg.0.log 這兩個檔案內容中並沒有 kdm 的相關錯誤訊息～
	很重要啊！因為某些套件如果沒有成功的啟動 X 時，他就無法提供登入呢～<br /><br />
	</div>

	<hr /><a name="xdmcp_client"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class=text_h2>用戶端登入</span><br />
	<div class=block2>
	<li><span class=text_import1>用戶端是 Linux 主機：</span></li>
	<div class=block2>
		如果想要進行 XDMCP 提供的 X 介面的登入 Linux 主機時，在 Linux 底下可是容易的很～
		底下的流程是在『用戶端』執行的喔～不是剛剛那部 XDMCP 所在的 Linux 主機啦！<br />

<table class="term"><tr><td class="term"><pre>
<span class=term_hd>0. 請務必要在 X Window 當中，進入 X Window 的方式有：</span>
[root@client ~]# <span class=term_command>startx</span>
<span class=term_say># 或</span>
[root@client ~]# <span class=term_command>init 5</span>
　
<span class=term_hd>1. 在 X Window 的畫面當中，啟用一個 shell ，然後輸入：</span>
[root@client ~]# <span class=term_command>xhost + 192.168.1.100</span>
192.168.1.100 being added to access control list
<span class=term_say># 假設我剛剛那部 Linux 主機的 IP 為 192.168.1.100</span>
[root@client ~]# <span class=term_command>init 3</span>   <span class=term_say>&lt;== 關閉 X Server</span>

<span class=term_hd>2. 在文字介面下輸入：</span>
[root@client ~]# <span class=term_command>X -query 192.168.1.100</span>
<span class=term_say># 進入 X Window 囉！</span>
</pre></td></tr></table>

		如果一切順利的話，您應該就能夠到 X Window 的畫面底下去登入遠端主機囉～<br /><br />
	</div>

	<li><span class=text_import1>用戶端是 Windows 主機：</span></li>
	<div class=block2>
		如果想要進行 XDMCP 提供的 X 介面的登入 Linux 主機時，在 Windows 
		底下就得要使用其他軟體來支援了。例如：

	<ul><li><a href="http://www.starnet.com/evalkey/" 
		target="_blank">X-Win32 (http://www.starnet.com/evalkey/)</a>
	<li><a href="http://www.hummingbird.com/products/nc/exceed/index.html?cks=y" 
		target="_blank">Exceed (http://www.hummingbird.com/products/nc/exceed/index.html?cks=y)</a></ul>

	這裡鳥哥用 X-Win32 來進行測試。正個運作流程是這樣的：

	<ol>

	<li>安裝 X-Win32 ，很簡單～就是直接執行下一步即可。比較可惜的是，這個軟體目前沒有中文支援喔！</li><br />

	<li>直接在『開始』-->『程式集』-->『X Win 32』執行『X-Win32』這支程式～會出現如下圖：<br /><br />
		<center><img src="0310telnetssh/x-win32-01.jpg"
			title="X Win 32 執行範例"
			alt="X Win 32 執行範例"><br />
			圖十、X Win 32 執行範例</center><br />

		上面只是在告訴我們，這個軟體需要註冊。但是我們只是試用而已，所以可以直接按下 Evaluation 即可。
		不過，試用版有連線三十分鐘的限制就是了～@_@ <br /><br />

	<li>在出現的視窗當中，當然要選擇 XDMCP 這個模式囉～<br /><br />
		<center><img src="0310telnetssh/x-win32-02.jpg"
			title="X Win 32 執行範例"
			alt="X Win 32 執行範例"><br />
			圖 11 、X Win 32 執行範例</center><br />

	<li>因為我們可以直接給予一個 X server 的 IP，所以這裡我們可以選擇『Query』這個項目。
		如果您是在 LAN 環境當中，而且 Client/Server 是在同一個網段時，其實可以選擇 Broadcast 
		比較好用！無論如何，這裡鳥哥先以 Query 來介紹。<br /><br />
		<center><img src="0310telnetssh/x-win32-03.jpg"
			title="X Win 32 執行範例"
			alt="X Win 32 執行範例"><br />
			圖 12 、X Win 32 執行範例</center><br />

	<li>接下來的畫面可以填入 IP 或主機名稱啊！建議直接輸入 IP 啦！<br /><br />
		<center><img src="0310telnetssh/x-win32-04.jpg"
			title="X Win 32 執行範例"
			alt="X Win 32 執行範例"><br />
			圖 13 、X Win 32 執行範例</center><br />

	<li>接下來的畫面只要填入一個簡單的好記得名稱即可！如果想要立即執行的話，那個『Launch this session now』
		可以直接打勾喔！<br /><br />
		<center><img src="0310telnetssh/x-win32-05.jpg"
			title="X Win 32 執行範例"
			alt="X Win 32 執行範例"><br />
			圖 14 、X Win 32 執行範例</center><br />

	<li>理論上，這樣應該就可以立即的進行連線到 X Window Server 才對。不過，如果沒有成功呢？
		沒關係！我們可以重新來修改一下設定啊～如果執行了 X-Win32 之後，在工作列的右下角會出現 X 圖示，
		如下所示：<br /><br />
		<center><img src="0310telnetssh/x-win32-06.jpg"
			title="X Win 32 執行範例"
			alt="X Win 32 執行範例"><br />
			圖 15 、X Win 32 執行範例</center><br />
		將滑鼠指標移動到 X 上頭，按下右鍵，可以得到如下的選單出現：<br /><br />
		<center><img src="0310telnetssh/x-win32-07.jpg"
			title="X Win 32 執行範例"
			alt="X Win 32 執行範例"><br />
			圖 16 、X Win 32 執行範例</center><br />
		在上圖上面按下『XConfig』就可以出現底下的圖示：<br /><br />
		<center><img src="0310telnetssh/x-win32-08.jpg"
			title="X Win 32 執行範例"
			alt="X Win 32 執行範例"><br />
			圖 17 、X Win 32 執行範例</center><br />
		然後選擇我們剛剛設定好的那個 session ，按下『Edit』，就可以開始修改剛剛的設定值囉～
		更多的選項請自行參考 X Win32 當中的說明。此時，我們可以在工作列的 X 上面，按下左鍵，
		應該會出現所有可以用的 session ，請選擇 linux.dmtsai.tw 那個 session ，如果一切順利，
		就會出現如下的畫面：<br /><br />
		<center><img src="0310telnetssh/x-win32-09.jpg"
			title="X Win 32 執行範例"
			alt="X Win 32 執行範例"><br />
			圖 18 、X Win 32 執行範例</center><br />
		輸入帳號密碼之後，嘿嘿！立刻就可以在 Windows 上面看到您 Linux 主機的 X Window 畫面了～
		感動吧～ ^_^
	</ol>

	<div style="padding: 10pt 0pt 10pt 0pt ;" align="right"><table width="90%"><tr><td><b>Tips:</b><br /><span style="color : #009000"><font size="-1">		事實上，xdmcp 真的很容易設定的～鳥哥曾經以 gdm (設定檔為 gdm.conf) 及 kdm 分別設定過，
		執行上都沒有問題。不過，需要特別留意的是，因為 X Window 執行的資料量實在是太大了，
		所以，如果您在 Internet 上面使用 ADSL 傳輸的話，想要玩這個玩意兒～
		奉勸您：『別想了～』這東西主要還是應用在內部網域當中的啦！
	</font></span></td><td><img src="/images/vbird_face.gif" alt="鳥哥的圖示" title="鳥哥的圖示" /></td></tr></table></div>
	</div>
	</div>

	<hr /><a name="xdmcp_close"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class=text_h2>關閉 XDMCP</span><br />
	<div class=block2>
		如果想要關掉的話，就這樣做：<br />

<table class="term"><tr><td class="term"><pre>
[root@linux xdm]# <span class=term_command>killall -9 kdm</span>
[root@linux xdm]# <span class=term_command>/etc/init.d/xfs stop</span>
</pre></td></tr></table>

		這樣就可以將 xdmcp 給他關掉囉～ ^_^
	</div>
</div>


<hr /><a NAME="vnc"></a><img src="/images/penguin-m.gif" alt="大標題的圖示" height="34" width="25" align="middle" /><span class="text_h1">VNC 伺服器</span><br />
<div class=block1>
	雖然 xdmcp 就已經很好用了，不過，就以傳輸速度上來講，他真的是慢啊～～
	這個時候，我們可以利用 VNC (Virtual Network Computing) 這個好用的咚咚來進一步設定我們的 
	X Window 登入系統喔。<br /><br />

	VNC 必須要透過 VNC Server 與 VNC client 軟體的呼相搭配，就可以進行比較快速一點的資料傳輸。
	而 VNC 如果想要漂亮的一點的話，也是需要搭配 xdmcp 的啦～因為如果是純粹使用 VNC 連接到 Xorg 
	(或 XFree86) 那個簡單的畫面，真的是....有點不好用～<br /><br />

	其實 VNC Server 會在主機多開一個程序在等待 Client 的登入要求，
	等到 Client 登入之後，才去執行 Window manager 的啟動。而這個 Window manager 的啟動方式有很多種，
	最陽春的就是利用 Xorg 預設的 twm 這個視窗管理程式，他真的是不好看～
	畫面有點像這樣：<br /><br />

		<center><img src="0310telnetssh/vnc-01.jpg"
			title="使用 twm 連線為 VNC Server 的執行範例"
			alt="使用 twm 連線為 VNC Server 的執行範例"><br />
			圖 19 、使用 twm 連線為 VNC Server 的執行範例</center><br />

	真的不很好看喔～那怎麼辦？其實我們可以透過更改 VNC 的啟動設定檔： xstartup 來設定不同的 Window manager ，
	另外，我們也可以透過啟用 kdm 或 gdm 這兩個好用的 display manager 來代為管理 Window manager 呢～
	鳥哥比較喜歡使用查詢 (Query) XDMCP 的方式來啟動 VNC ，而不是直接啟動 startkde 這個程式的說～
	所以，底下我們就直接來設定可以連接到 xdmcp 上的 VNC Server 吧！<br />

<table class="term"><tr><td class="term"><pre>
<span class=term_hd>1. 先讓 kdm 支援 xdmcp 模式</span>
[root@linux ~]# <span class=term_command>cd /etc/X11/xdm</span>
[root@linux xdm]# <span class=term_command>vi kdmrc</span>
<span class=term_write>[Xdmcp]
Enable=1</span>

<span class=term_hd>2. 讓 client 可以透過 X 來登入系統！與權限有關的設定</span>
[root@linux xdm]# <span class=term_command>vi Xaccess</span>
<span class=term_write>*</span>

<span class=term_hd>3. 啟動 kdm 喔！</span>
[root@linux xdm]# <span class=term_command>/etc/init.d/xfs start</span>
[root@linux xdm]# <span class=term_command>kdm</span>
[root@linux xdm]# <span class=term_command>netstat -tlunp</span>
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address  Foreign Address  State  PID/Program name
tcp        0      0 0.0.0.0:6000   0.0.0.0:*        LISTEN 5920/X
tcp        0      0 :::6000        :::*             LISTEN 5920/X
udp        0      0 :::177         :::*                    5918/kdm
<span class=term_say># 要看到有 177 的 udp port 與 port 6000 才行；
# 如果沒有看到的話，就得要查詢底下幾個檔案的內容，看看錯誤訊息了！
# a. 必須查閱 netstat -tlunp
# b. 必須查閱 /var/log/Xorg.log.0
# c. 必須查閱 /var/log/messages
# d. 必須查閱 /var/log/kdm.log</span>

<span class=term_hd>4. 用某身份建立 passfile 給 VNC 連線時使用</span>
<span class=term_say># 因為 VNC 開的每個 port 都是給某特定使用者登入的，因此，
# 每個 VNC server 都會啟用自己的 port 呢～據說最大可開放到 10 個～
# 鳥哥這裡假設利用 dmtsai 這個使用者來執行 VNC ，那麼他就必須要有底下幾個動作：</span>
<span class=term_hd>4.1 建立連線用密碼</span>
[root@linux xdm]# <span class=term_command>su dmtsai</span>
[dmtsai@linux xdm]$ <span class=term_command>vncpasswd</span>
Password: <span class=term_note>&lt;== 這裡請輸入密碼</span>  
Verify: <span class=term_note>&lt;== 再輸入一次～</span>
<span class=term_say># 特別注意，為了安全起見，密碼的長度是有限制的！
# 至少要大於六個字元，且不能與帳號相同～
# 密碼建立後，會在 /home/dmtsai/.vnc/passwd 這個檔案中記錄了你的密碼～
# 同時，在這個目錄下，還有設定檔 xstartup 可以利用喔！ ^_^</span>
<span class=term_hd>4.2 修改設定檔 xstartup</span>
[dmtsai@linux xdm]$ <span class=term_command>vi /home/dmtsai/.vnc/xstartup</span>
<span class=term_say># 將這個檔案內的所有資料通通給他註解掉～不需要保留～</span>
<span class=term_hd>4.3 離開此一身份使用者的畫面</span>
[dmtsai@linux xdm]$ <span class=term_command>exit</span>

<span class=term_hd>5. 修改 /etc/sysconfig/vncserver 檔案內容</span>
<span class=term_say># 這個檔案是 FC4 預設的啟動 VNC 的讀取檔，所以我們可以修改他～</span>
[root@linux xdm]# <span class=term_command>vi /etc/sysconfig/vncservers</span>
<span class=term_say># 將原本的資料改成這樣：</span>
<span class=term_write>VNCSERVERS="2:dmtsai"
VNCSERVERARGS[2]="-geometry 800x600 -query localhost"</span>
<span class=term_say># 意思是說，我們要啟動一個 VNC 在 port 5900+2 即 5902 的意思，</span>

<span class=term_hd>6. 啟動 VNC server </span>
[root@linux xdm]# <span class=term_command>/etc/init.d/vncserver start</span>
<span class=term_say># 此時在 /home/dmtsai/.vnc/ 裡面應該會有幾個檔案您應該要注意的，
# 最重要的就是 dmtasi.linux.dmtsai.tw:2.log 這個檔案，檔名的由來是：
# username.hostname.domainname:[port number].log ，因為我們是啟用 5902 ，
# 所以就有 :2.log 的附檔名啦～務必看到裡面沒有錯誤才行喔～
# 如果發現找不到/usr/X11R6/lib/X11/xserver/SecurityPolicy 的錯誤，先略過不要緊～</span>

<span class=term_hd>7. 查閱設定結果</span>
[root@linux xdm]# <span class=term_command>netstat -tulnp</span>
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address Foreign Address State    PID/Program name
tcp        0      0 0.0.0.0:5802  0.0.0.0:*       LISTEN   15287/Xvnc
tcp        0      0 0.0.0.0:5902  0.0.0.0:*       LISTEN   15287/Xvnc
tcp        0      0 0.0.0.0:6000  0.0.0.0:*       LISTEN   15019/X
tcp        0      0 0.0.0.0:6002  0.0.0.0:*       LISTEN   15287/Xvnc
tcp        0      0 :::6000       :::*            LISTEN   15019/X
tcp        0      0 :::6002       :::*            LISTEN   15287/Xvnc
udp        0      0 0.0.0.0:32924 0.0.0.0:*                15287/Xvnc
udp        0      0 :::177        :::*                     15017/kdm
</pre></td></tr></table>

	設定好像也很簡單喔～那麼鳥哥幹嘛講這麼多原理？
	原因無他，因為希望大家可以在不同的 Linux distributions 也能夠順利的架設好
	XDMCP 與 VNC ，如果您能夠善用登錄檔的內容資訊，
	那麼應該會比較容易 debug 的啦～ ^_^<br /><br />

	另外，事實上啟動 VNC 的 script 是由 vncserver 這個指令所啟用的，
	您也可以直接利用某個身份直接下達：<BR>

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>vncserver :3</span>

You will require a password to access your desktops.

Password: <span class=term_note>&lt;== 就輸入密碼吧！</span>
Verify: <span class=term_note>&lt;== 再輸入密碼吧！</span>

New 'dmtsai.linux.dmtsai.tw:3 (dmtsai)' desktop is dmtsai.linux.dmtsai.tw:3

Starting applications specified in /root/.vnc/xstartup
Log file is /root/.vnc/dmtsai.linux.dmtsai.tw:3.log
</pre></td></tr></table>

	如此一來，就可以啟用一個 port 為 5903 的 VNC 服務囉～
	您可以再度的去到 logfile 查一查啊～至於關閉的話，可以用：<br />

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>vncserver -kill :3</span>
</pre></td></tr></table>

	這樣就能夠關閉囉～呵呵！那麼如果想要連接到 VNC Server 的話，
	在 Linux 底下可以利用 KDE 的 krdc 這支遠端連線程式，如果是 Windows 的話，
	就得需要 VNC Client 囉～您可以前往底下的網站：

	<ul><li><a href="http://www.realvnc.com/download.html" 
		target="_blnak">http://www.realvnc.com/download.html</a></ul>

	直接下載 Free Edition 來測試看看就好了。安裝過程我們就不提了～
	安裝完畢之後，直接執行『開始』-->『程式集』-->『RealVNC』-->『Run VNC viewer』後，
	出現如下的視窗：<br /><br />

	<center><img src="0310telnetssh/realvnc-01.jpg"
		title="VNC viewer 執行範例"
		alt="VNC viewer 執行範例"><br />
		圖 20 、VNC viewer 執行範例</center><br />

	輸入了您的主機 IP 與該 VNC 對應的 port 之後，會出現一個密碼視窗：<br /><br />

	<center><img src="0310telnetssh/realvnc-02.jpg"
		title="VNC viewer 執行範例"
		alt="VNC viewer 執行範例"><br />
		圖 21 、VNC viewer 執行範例</center><br />

	記得啊～這裡的密碼指的是『您利用 vncpasswd 所建立的密碼』，而不是登入者的密碼啊～
	按下 Enter 之後，如果順利的話，就會出現如下的圖示囉～<br /><br />

	<center><img src="0310telnetssh/realvnc-03.jpg"
		title="VNC viewer 執行範例"
		alt="VNC viewer 執行範例"><br />
		圖 22 、VNC viewer 執行範例</center><br />

	<center><img src="0310telnetssh/realvnc-04.jpg"
		title="VNC viewer 執行範例"
		alt="VNC viewer 執行範例"><br />
		圖 23 、VNC viewer 執行範例</center><br />

	很不錯吧！ ^_^ 這樣就能夠在 Client 端登入 Linux 主機囉～
	而且還可以多人共用呢～真是棒～ ^_^。但是，如果您設定完畢之後，
	在登錄檔老是出現這個咚咚：
	『XDMCP fatal error: Manager unwilling Host unwilling』，
	就是 /etc/X11/xdm/Xaccess 這個檔案的設定需要變更了！<br /><br />

	另外，有些朋友一定會覺得奇怪，那就是，為甚麼我的 VNC 伺服器的 server / client 端畫面並不是同步的呢?
	這是因為 Linux 本身提供多個 VNC server ，她們是各自獨立的，所以當然就不會與 tty7 的畫面同步了。
	但是如果您想要與 Linux 的 tty7 同步的話，可以利用 VNC 釋出的給 X Server 使用的模組來加以設定即可。
	如果您是 CentOS 4.x 這個 distribution 的話，恭喜您，系統預設已經將 vnc.so 這個模組釋出了，您可以查閱
	/usr/X11R6/lib/modules/extensions/ 這個檔案，即可知道有沒有 vnc.so 這個模組。如果您沒有這個模組的話，
	請參考 <a href="http://phorum.study-area.org/viewtopic.htm?t=25713"
	target="_blank">http://phorum.study-area.org/viewtopic.htm?t=25713</a> 這一篇文章的說明，
	依序來設定吧!<br />

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>vi /etc/X11/xorg.conf (或 XF86Config)</span>
Section "Module"
	....
        <span class=term_write>Load  "vnc"</span>
EndSection
<span class=term_say># 在 Module 這個 section 當中加入 vnc 這個模組即可</span>
Section "Screen"
        Identifier "Screen0"
        Device     "Videocard0"
        Monitor    "Monitor0"
        <span class=term_write>Option     "passwordFile"  "/etc/vnc/passwd"</span>
        DefaultDepth     16
	......
EndSection
<span class=term_say># 假設您的 vnc 密碼檔案放置在 /etc/vnc/passwd 裡頭，
# 這個時候就得要將密碼檔內容寫到 Screen 這個 section 當中了</span>
</pre></td></tr></table>

	此時給他重新啟動一下 kdm 或者是重新進入 run level 5 的時候，您就會發現多了一個 port 5900 呢，
	嘿嘿，準備同步登入吧 ^_^<br /><br />
</div>


<hr /><a NAME="rsh"></a><img src="/images/penguin-m.gif" alt="大標題的圖示" height="34" width="25" align="middle" /><span class="text_h1">RSH 伺服器</span><br />
<div class=block1>
	什麼是 RSH 伺服器呢？其實，這是早期的不同主機之間互相『直接操作』對方資源的一個方法。
	其實就好像使用『 ssh dmtsai@localhost date 』之類的執行方法啦！
	我們可以透過 rsh 來操作對方主機啊。這個 RSH 就是被稱為 R Shell 的咚咚囉～<br /><br />

	目前 RSH 很少被使用到一般的伺服器上面，尤其是對 Internet 開放的主機，
	這是因為 RSH 的危險性很高！他不但是明碼傳輸，而且一個設定不良，可能會讓所有人都能使用 RSH 來登入主機！
	不過，RSH 卻是操作叢集電腦 (cluster) 裡面最常見的服務之一！<br /><br />

	所謂的叢集電腦，簡單的說就是『<span class=text_import2>將很多部主機透過網路連結在一起，
	以其中一部主機作為主要操控電腦 (或者稱為 master) ，其他主機僅負責來自 master 的要求 
	(所以被稱為 slave)；所有的電腦工作都是由 master 所掌控， slave 僅負責運算的部分。</span>』
	這也就是說， slave 大概就僅提供 CPU 的運算單元，其他的事都是 master 負責來運作。
	當然，我們也是只要操控 master 那部主要電腦而已。在這樣的情況下， slave 接受 master 的指令，
	最主要就是透過 RSH 啊！ (當然，也可以透過 SSH 配合金鑰來達成這樣的工作！)。
	關於更多的 cluster  的介紹，可以參考一下鳥哥之前寫的一篇小文章：
	<ul><a href="http://linux.vbird.org0600cluster.htm"
		target="_blank">http://linux.vbird.org0600cluster.htm</a></ul>

	至於 RSH server 與 Client 的互動可以使用下面的圖示來查閱：<br /><br />

	<a name="fig_24"></a><center><img src="0310telnetssh/rsh.png" border=1
		title="RHS Server/Client 互動示意圖"
		alt="RHS Server/Client 互動示意圖"><br />
		圖 24 、RHS Server/Client 互動示意圖</center><br />

	上圖中在 RSH server 當中的幾個設定檔是這樣的：<br />
	<ul>
	<li><span class=text_import1>/etc/hosts</span>：主要規範 RSH server/client 的主機名稱與 IP 對應！
	<li><span class=text_import1>/etc/hosts.equiv</span>：規範出哪一部 client 可以連上這部 RSH server；
	<li><span class=text_import1>~user/.rhosts</span>：規範出那個使用者可以不需要輸入密碼即可執行 RSH；
	<li><span class=text_import1>/etc/pam.d/rsh</span>：規範 root 能否使用 RSH 的設定檔。
	</ul>


	雖然 RSH 目前已經很少被使用，但是在內部主機的連線上面還是有他的存在的價值啦！
	因此，底下我們就來談一談如何玩弄這個 RSH 吧！<br /><br />

	<hr /><a name="rsh_server"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class=text_h2>RSH Server</span><br />
	<div class=block2>
		其實 R Shell 有很多的工具與啟動的 port ，常見的 R Shell 工具有 rexec, rlogin, rsh 等，
		而這些工具都對應到不同的 port 上面，你可以到 /etc/services 上查閱一下 512, 513, 514 這三個 port 吧！<br /><br />

		<hr /><li><span class=text_import1>RSH Server 的啟動：</span></li>
		<div class=block2>
		如<a href="#fig_24">圖 24</a> 所示，我們在 RSH Client 電腦上面想要使用 RSH Server 上頭的資料時，
		那麼 RSH server 自然就得要啟動 RSH 這項服務囉！那麼如何啟動呢？簡單的很～
		就利用 super deamon 來啟動，
		<span class=text_import2>我們需要有 rsh 及 rsh-server 兩個套件才行</span>！請自行安裝吧！
		另外， rsh-server 共提供三個服務，分別是『 rexec, rlogin, rsh 』，我們先單純討論 rsh 吧！
		安裝完畢之後，直接啟動即可：<br />

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>vi /etc/xinetd.d/rsh</span>
service shell
{
        <span class=term_write>disable                 = no</span>
        socket_type             = stream
        wait                    = no
        user                    = root
        log_on_success          += USERID
        log_on_failure          += USERID
        server                  = /usr/sbin/in.rshd
}
<span class=term_say># 沒錯！只要將 disable 改成 no  即可！</span>

[root@linux ~]# <span class=term_command>/etc/init.d/xinetd restart</span>

[root@linux ~]# <span class=term_command>netstat -tlnp | grep 514</span>
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address Foreign Address State  PID/Program name
tcp        0      0 0.0.0.0:514   0.0.0.0:*       LISTEN 23369/xinetd
<span class=term_say># 有看到 514 的 port 出現就對了！</span>
</pre></td></tr></table>
		</div>

		<hr /><li><span class=text_import1>設定可以使用 RSH 的來源主機與帳號： /etc/hosts, 
		/etc/hosts.equiv, ~user/.rhosts</span></li>
		<div class=block2>
		假設我已經在 /etc/hosts 裡面做好了我內部主機的 IP 與主機名稱的對應了，
		例如，我 192.168.1.2 機器的 /etc/hosts 裡面是這樣的：<br />

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>vi /etc/hosts</span>
127.0.0.1       localhost       localhost.localdomain
192.168.1.2     rsh.server      rshserver
192.168.1.100   rsh.client      rshclient
<span class=term_say># 上面僅有兩部主機，假設 RSH server 的 IP 是 192.168.1.2 啦！</span>
</pre></td></tr></table>

		這個檔案很重要，因為我們的 RSH 通常是利用主機名稱來作為指令的下達的，
		所以囉，您區域網路內的主機名稱與 IP 必須要設定的能夠對應的起來，否則問題就大了。
		在上表當中，你會發現到，其實鳥哥的重點是那部 rsh.server 的機器，
		當我想要讓 192.168.1.100 亦即是 rsh.client 那部機器連進來 rsh.server 執行一些指令的話，
		那我就得要啟動權限才行！此時就得要 /etc/hosts.equiv 來處理了。這個檔案的格式是這樣的：<br />

<a name="hosts.equiv"></a>
<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>vi /etc/hosts.equiv</span>
<span class=term_write>rsh.client dmtsai</span>
<span class=term_say># 這個檔案的格式是 [hostname] [username]
# 將你要開放的使用者與某主機給他對應好寫上去即可！</span>
</pre></td></tr></table>

		這樣就做好了設定了！未來任何想要登入這部 rsh.server 機器的主機，只要將他的主機名稱與 IP 對應寫入
		/etc/hosts ，然後再將該主機名稱寫入 /etc/hosts.equiv ，就成功了！
		這個檔案的設計只要是在規範『可以不用輸入密碼就能夠進入本機執行指令』的設定啦！
		但是請注意，『<span class=text_import2>在預設的情況下， root 是不允許使用 rsh 
		登入 rsh.server 機器的。</span>』這個很重要！不要使用 root 一直測試啊！沒有用的。
		更多的 hosts.equiv 設定值，請參考 man hosts.equiv 囉！<br /><br />

		<a name="rhosts"></a>
		但你可能會發現一件事，那就是每部主機與使用者都需要配合的話，但 /etc/hosts.equiv 預設僅有 root 可修改，
		如此一來實在不好管理！此時我們可以使用使用者家目錄的檔案來處理喔！那就是 ~/.rhosts 囉！
		這個檔案的設定就更簡單了！只要將使用者預計要登入的那部主機名稱寫入即可！<br />

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>vi ~dmtsai/.rhosts</span>
<span class=term_write>rsh.client</span>
</pre></td></tr></table>

		這樣就 OK 啦！意思是說，我這部 rsh.server 上有個 dmtsai 的使用者，他可以讓 rsh.client
		這個主機登入並且不需要密碼即可進行 R Shell 的相關指令下達工作！
		同樣的，如果我還想讓其他使用者可以由不同的主機登入這部 rsh.server 進行 RSH 的話，
		同樣在他的家目錄新增 .rhosts 這個檔案即可！如果想要讓未來新增的使用者都具有這個功能，
		那就這樣做：<br />

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>vi /etc/skel/.rhosts</span>
<span class=term_write>rsh.client</span>
</pre></td></tr></table>

		未來新增使用者時，他們的家目錄底下就會自動產生 .rhosts 的檔案囉！ ^_^<br />
		</div>

		<hr /><li><span class=text_import1>讓 root 也可以使用 RSH ：</span></li>
		<div class=block2>
		先通知一聲，鳥哥不建議您這樣做！但是，如果萬一您需要某些服務是 root 也需要的，
		那或許就得要開放 root 使用 RSH 登入主機了。其實 root 不能使用 rsh 
		是因為 PAM 的問題而已，所以，你只要將 /etc/pam.d/rsh 這個檔案註解掉一行即可：<br />

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>vi /etc/pam.d/rsh</span>
#%PAM-1.0
# For root login to succeed here with pam_securetty, "rsh" must be
# listed in /etc/securetty.
auth       required     pam_nologin.so
<span class=term_write>#auth       required    pam_securetty.so</span>
auth       required     pam_env.so
auth       required     pam_rhosts_auth.so
account    required     pam_stack.so service=system-auth
session    required     pam_stack.so service=system-auth
</pre></td></tr></table>

		將上面這一行註解掉，立刻就能讓 root 登入 rsh 主機啦！當然啦，如果您擔心有問題，
		那麼修改另一個檔案也可以：<br />

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>vi /etc/securetty</span>
<span class=term_say>.....(省略).....</span>
<span class=term_write>rsh</span>
</pre></td></tr></table>

		加入這一行也行！注意，上面這兩個檔案是具有相關性的，所以，您只要修改任何一個即可，
		不必兩個同時進行！然後將主機名稱與 root 的對應寫入 <a href="#hosts.equiv">/etc/hosts.equiv</a>
		檔案中即可！你的 root 就能夠使用 rsh 囉！但是，鳥哥還是不很建議開放 root 使用 RSH 喔！注意注意！<br />
		</div>
	</div>

	<hr /><a name="rsh_client"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class=text_h2>RSH Client</span><br />
	<div class=block2>
		這個 RSH client 的指令 rsh 預設是不給 root 執行的！所以不要使用 root 來測試！
		另外， RSH Client 最好與 RSH server 具有相同的帳號來執行 rsh 比較不會有問題喔！<br /><br />

		<a name="rsh_cmd"></a><hr /><li><span class=text_import1>測試 RSH ：</span></li>
		<div class=block2>
		接下來，當然要進行測試囉～請到 rsh.client 那部機器上面，使用 rsh 這個指令來下達指令吧！<br />

<table class="term"><tr><td class="term"><pre>
[dmtsai@rshclient ~]$ <span class=term_command>rsh [-l 遠端帳號] [遠端主機名] [遠端主機指令]</span>
<span class=term_say>參數：
-l   ：一般來說， server 與 client 『要有相同的使用者帳號名稱』比較好的！
       如果沒有的話，那麼您必須要指定 server 的使用者帳號名才行！
遠端主機名  ：您要登入的那部 rsh.server 主機名稱，記得與 /etc/hosts 相應！
遠端主機指令：您要在遠端機器上面下達什麼指令？</span>

<span class=term_hd>範例一：在 rsh.server 上面下達 ls -l / 這個指令：</span>
[dmtsai@rshclient ~]$ <span class=term_command>rsh rsh.server 'ls -l /'</span>
<span class=term_say>.....輸出省略.....</span>
<span class=term_say># 注意喔，我是使用 dmtsai 這個一般身份使用者，而且 rshserver rshclient
# 兩部主機上面都有一個名為 dmtsai 的使用者帳號才行喔！至於那個 ls -l /
# 則是在 rsh.server 主機上面的指令！留意留意！</span>
</pre></td></tr></table>

		一般來說，由於 RSH server/client 最好是要有相同的帳號，如此一來才能夠避免很多不必要的權限問題(
		permission denied. )。所以說，通常 RSH 可能會搭配後續會繼續談到的 NIS/NFS 等伺服器才是！
		這樣瞭呼？<br /><br />

		另外， rsh 後續的指令通常僅適合單一指令而已，所以如果你的指令串很長 (接了很多參數)，
		那最好將那一整串指令用單引號括起來，可以避免指令下達錯誤的問題喔！ ^_^<br /><br />
		</div>

		<a name="rcp"></a><hr /><li><span class=text_import1>利用 rcp 複製：</span></li>
		<div class=block2>
		除了 rsh 可以在遠端直接操控系統外，我們可以透過 rcp 來進行複製喔！其實這個 rcp 與 scp 幾乎一模一樣啦！
		而且 rcp 的參數幾乎與 cp 一模一樣哩！另外， rcp 也是透過 RSH 這個 514 的 port 來進行資料的傳輸的。
		簡單的說明如下：<br />

<table class="term"><tr><td class="term"><pre>
<span class=term_hd>範例：先查閱遠端主機有什麼資料，然後將他複製過來：</span>
[dmtsai@rshclient ~]# <span class=term_command>rsh rsh.server 'ls -l ~'</span>
drwx------  3 dmtsai dmtsai     4096 Dec 27  2005 Desktop
-rw-r--r--  1 dmtsai dmtsai     3385 May 29 17:52 bashrc
drwx------  3 dmtsai dmtsai     4096 Mar  6  2006 mail
-rw-r--r--  1 dmtsai dmtsai   883888 May 29 17:51 netcdf.tar.gz
drwxr-xr-x  2 dmtsai dmtsai     4096 Jul 26 16:05 test
-rw-rw-r--  1 dmtsai dmtsai    34816 Mar 19  2006 testing.ppt

[dmtsai@rshclient ~]# <span class=term_command>rcp -r dmtsai@rsh.server:~/mail .</span>
<span class=term_say># 加上 -r 是為了要複製目錄喔！否則的話，可以直接複製即可！</span>
</pre></td></tr></table>

		再說一次，其實這個 RSH 目前僅有在某些特殊的場合才會用到了！
		例如未來流行的新資訊『 Cluster 』！不過如果要玩 Cluster 的話，
		得要加入 NIS/NFS 等伺服器哩！那就等您好好發展啦！ ^_^
		</div>
	</div>
</div>


<hr /><a name="rsync"></a><img src="/images/penguin-m.gif" alt="大標題的圖示" height="34" width="25" align="middle" /><span class=text_h1>以 rsync 進行同步鏡相備份</span><br />
<div class=block1>
	我們曾在基礎篇裡面談過 <a href="../linux_basic/0580backup.htm">Linux 的備份策略</a>，
	該篇曾介紹常用的備份指令，包括 tar, dd, cp 等等，不過當時並未介紹網路，所以有個很棒的網路工具沒有介紹，
	那就是這個地方要談到的 rsync 啦！這個 rsync 可以作為一個相當棒的異地備援系統的備份指令喔！
	因為 rsync 可以達到類似『鏡相 (mirror) 』的功能呢！<br /><br />

	rsync 最早是想要取代 rcp 這個指令的，因為 rsync 不但傳輸的速度快，而且他在傳輸時，
	可以比對本地端與遠端主機欲複製的檔案內容，而僅複製兩端有差異的檔案而已，所以傳輸的時間就相對的降低很多！
	此外， rsync 的傳輸方式至少可以透過三種方式來運作：<br />

	<ul><span class=text_import2>
	<li>在本機上直接運作，用法就與 cp 幾乎一模一樣，例如：<br />
		rsync -av /etc /tmp (將 /etc/ 的資料備份到 /tmp/etc 內)<br /><br />
	<li>透過 rsh 或 ssh 的通道在 server / client 之間進行資料傳輸，例如：<br />
		rsync -av -e ssh user@rsh.server:/etc /tmp (將 rsh.server 的 /etc 備份到本地主機的 /tmp 內)<br /><br />
	<li>直接透過 rsync 提供的服務 (daemon) 來傳輸，此時 rsync 主機需要啟動 873 port：<br />
		1. 你必須要在 server 端啟動 rsync ， 看 /etc/xinetd.d/rsync 即可；<br />
		2. 你必須編輯 /etc/rsyncd.conf 設定檔；<br />
		3. 你必須設定好 client 端連線的密碼資料；<br />
		4. 在 client 端可以利用：rsync -av user@hostname::/dir/path /local/path<br />
	</span></ul>

	其實三種傳輸模式差異在於有沒有冒號 (:) 而已，本地端傳輸不需要冒號，透過 ssh 或 rsh 時，就得要利用一個冒號 (:)，
	如果是透過 rsync daemon 的話，就得要兩個冒號 (::) ，應該不難理解啦！因為本地端處理很簡單，
	而我們的系統本來就有提供 ssh 的服務，所以，底下鳥哥將直接介紹利用 rsync 透過 ssh 來備份的動作喔。
	不過，在此之前咱們先來看看 rsync 的語法吧！<br />

<table class="term"><tr><td class="term"><pre>
[root@linux ~]# <span class=term_command>rsync [-avrlptgoD] [-e ssh] [user@host:/dir] [/local/path]</span>
<span class=term_say>參數：
-v ：觀察模式，可以列出更多的資訊；
-q ：與 -v  相反，安靜模式，輸出的資訊比較少；
-r ：遞迴複製！可以針對『目錄』來處理！很重要！
-u ：僅更新 (update)，不會覆蓋目標的新檔案；
-l ：複製連結檔的屬性，而非連結的目標原始檔案內容；
-p ：複製時，連同屬性 (permission) 也保存不變！
-g ：保存原始檔案的擁有群組；
-o ：保存原始檔案的擁有人；
-D ：保存原始檔案的裝置屬性 (device)
-t ：保存原始檔案的時間參數；
-I ：忽略更新時間 (mtime) 的屬性，檔案比對上會比較快速；
-z ：加上壓縮的參數！
-e ：使用的通道協定，例如使用 ssh 通道，則 -e ssh
-a ：相當於 -rlptgoD ，所以這個 -a 是最常用的參數了！
更多說明請參考 man rsync 的解說！</span>

<span class=term_hd>範例一：將 /etc 的資料備份到 /tmp 底下：</span>
[root@linux ~]# <span class=term_command>rsync -av /etc /tmp</span>
<span class=term_say>....前面輸出省略....</span>
sent 23007335 bytes  received 32280 bytes  5119914.44 bytes/sec
total size is 22870014  speedup is 0.99
<span class=term_say># 第一次運作時會花比較久的時間，因為首次建立嘛！如果再次備份呢？</span>

[root@linux ~]# <span class=term_command>rsync -av /etc /tmp</span>
building file list ... done
sent 77105 bytes  received 20 bytes  154250.00 bytes/sec
total size is 22870014  speedup is 296.53
<span class=term_say># 瞧！立刻就跑完了！傳輸的資料也很少！因為再次比對，僅有差異的檔案會被複製。</span>

<span class=term_hd>範例二：利用 dmtsai 的身份，將 rsh.server 使用者家目錄複製到 /tmp </span>
[root@linux ~]# <span class=term_command>rsync -av -e ssh dmtsai@rsh.server:~ /tmp </span>
The authenticity of host 'rsh.server (192.168.1.2)' can't be established.
RSA key fingerprint is 29:b8:a9:32:ea:d8:ff:97:6c:42:3b:aa:11:ab:55:dd.
Are you sure you want to continue connecting (yes/no)? <span class=term_command>yes</span>
Warning: Permanently added 'rsh.server' (RSA) to the list of known hosts.
dmtsai@rsh.server's password:
receiving file list ... done
<span class=term_say>....檔案輸出省略....</span>
sent 8436 bytes  received 43224862 bytes  2789245.03 bytes/sec
total size is 43189031  speedup is 1.00

[root@linux ~]# <span class=term_command>ll -d /tmp/dmtsai</span>
drwxr-xr-x  22 dmtsai dmtsai  4096 Sep 18 23:25 /tmp/dmtsai
<span class=term_say># 瞧！這樣就做好備份啦！很簡單吧！</span>
</pre></td></tr></table>

	你可以利用上面的範例二來做為備份 script 的參考！不過要注意的是，
	因為 rsync 是透過 ssh 來傳輸資料的，所以你可以針對 dmtsai 這個傢伙製作出免用密碼登入的 ssh 金鑰！
	如此一來往後異地備援系統就能夠自動的以 crontab 來進行備份了！簡單到爆！<br /><br />

	免密碼的 ssh 帳號我們在上頭已經講過了，撰寫 shell script 的能力也是必須要有的！
	利用 rsync 來進行你的備份工作吧！ ^_^！
	至於更多的 rsync 用法可以參考本章後面所列出的<a href="#reference">參考資料</a>網站喔！<br /><br />
</div>


<hr /><a NAME="review"></a><img src="/images/penguin-m.gif" alt="大標題的圖示" height="34" width="25" align="middle" /><span class=text_h1>重點回顧：</span><br />
<div class=block1>
<ul><span class=text_import2>
	<li>遠端連線伺服器可以讓使用者在任何一部電腦登入主機，以使用主機的資源或管理與維護主機；
	<li>常見的遠端登入服務有 rsh, telnet, ssh, vnc, 及 xdmcp 等；
	<li>telnet 與 rsh 都是以明碼傳輸資料，當資料在 Internet 上面傳輸時較不安全；
	<li>telnet 與 rsh  預設無法讓 root 的身份登入，不過可以藉由 pam 模組的修改而啟用 root 登入功能；
	<li>ssh 由於使用金鑰系統，因此資料在 Internet 上面傳輸時是加密過的，所以較為安全；
	<li>但 ssh 還是屬於比較危險的服務，請不要對整個 Internet 開放 ssh 的可登入權限，可利用 iptables 規範可登入範圍；
	<li>ssh 的 public Key 是放在主機端，而 private key 是放在 client 端；
	<li>ssh 的連線機制有兩種版本，建議使用可確認連線正確性的 version 2 ；
	<li>使用 ssh 時，盡量使用類似 email 的方式來登入，亦即： ssh username@hostname
	<li>client 端可以比對 server  傳來的 public key 的一致性，利用的檔案為 ~user/.ssh/known_hosts；
	<li>ssh 的 client 端軟體提供 ssh, scp, sftp 等程式；
	<li>在 /etc/ssh/sshd_config 當中可以取消 root 的登入權限與修改支援的 ssh 金鑰版本；
	<li>製作不需要密碼的 ssh 帳號可利用 ssh-keygen -t rsa 來製作 public, private Key pair；
	<li>上述指令所製作出的 public key 必須要上傳到 server 的 ~user/.ssh/authorized_keys 檔案中；
	<li>如果想以 X 圖形系統登入 Linux 主機，則你必須要在 Client 主機啟動 X server ，
		需要在 Linux 主機啟動 X client ；
	<li>Xdmcp 是透過 X display manager (xdm, gdm, kdm 等) 所提供的功能協定；
	<li>若 client 端為 Linux 時，需要在 X 環境下以 xhost 增加可連接到本機 X Server 的 IP 才行；
	<li>除了 Xdmcp 之外，我們可以利用 VNC 來進行 X 的遠端登入架構；
	<li>VNC 預設開的 port number 為 5900  開始，每個 port 僅允許一個連線；
	<li>控制 rsh client 是否可以連線進入的設定檔在 /etc/hosts.equiv 或 ~username/.rhosts ；
	<li>rsh 支援的 client 端軟體有 rsh, rlogin, rcp  等；
	<li>rsync 可透過 ssh 的服務通道或 rsync --daemon 的方式來連線傳輸，其主要功能可以透過類似鏡像備份，
		僅備份新的資料，因此傳輸備份速度相當快速！
</span></ul>
</div>


<hr /><a NAME="FAQ"></a><img src="/images/penguin-m.gif" alt="大標題的圖示" height="34" width="25" align="middle" /><span class="text_h1">課後練習</span><br />
<div class=block1>
<ul>
	<li>Telnet 與 SSH 都是遠端連線伺服器，為何我們都會推薦使用 SSH 而避免使用 Telnet 呢？原因何在？</li>
	<div class=block2><font color=white size=-1>
	因為 Telnet 除了使用『明碼』傳送資料外，本身 telnet 就是很容易被入侵的一個伺服器，所以當然也就比較危險了。
	至於 ssh 其實也不是很安全的！由台灣電腦危機處理小組的文件可以明顯的發現 openssl + openssh 
	也是常常有漏洞在發佈！不過，比起 telnet 來說，確實是稍微安全一些！ 
	</font></div>

	<li>請嘗試說明 SSH 在 Server 與 Client 端連線時的封包加密機制；</li>
	<div class=block2><font color=white size=-1>
	利用 key pair 來達到加密的機制：Server 提供 Public Key 給 Client 端演算 Private key ，以提供封包傳送時的加密、解密！
	</font></div>

	<li>請問 SSH 的設定檔是哪一個？如果我要修改讓 root 無法使用 SSH 連線進入我的
	SSH 主機，應該如何設定？又，如果要讓 badbird 這個使用者無法登入 SSH 主機，該如何設定？</li>
	<div class=block2><font color=white size=-1>
	SSH 設定檔檔名為 sshd_config ，通常放置在 /etc/ssh/sshd_config 內；如果不想讓 root 登入，可以修改 
	sshd_config 內的參數成為：『PermitRootLogin no 』，並重新啟動 ssh 來設定！如果要讓 badbird 
	使用者無法登入，同樣在 sshd_config 裡面設定為：『DenyUsers badbird』即可！
	</font></div>

	<li>在 Linux 上，預設的 Telnet 與 SSH 伺服器使用的埠口(port number)各為多少？</li>
	<div class=block2><font color=white size=-1>
	telnet 與 ssh 的埠口分別是：23 與 22！請參考 /etc/services 喔！ 
	</font></div>

	<li>如果發現我無法在 Client 端使用 ssh 程式登入我的 Linux 主機，但是 Linux
	主機卻一切正常，可能的原因為何？(防火牆、known_hosts...)</li>
	<div class=block2><font color=white size=-1>
	無法登入的原因可能有很多，最好先查詢一下 /var/log/messages 裡面的錯誤訊息來判斷，當然，還有其他可能的原因為：
	<ol>
	<li>被防火牆擋住了，請以 iptables -L -n 來察看，當然也要察看 /etc/hosts.deny；
	<li>可能由於主機重新開機過， public key 改變了，請修改您的 ~/ssh/known_hosts 裡面的主機 IP ；
	<li>可能由於 /etc/ssh/sshd_config 裡面的設定問題，導致您這個使用者無法使用；
	<li>在 /etc/passwd 裡面，您的 user 不具有可以登入的 shell ；
	<li>其他因素(如帳號密碼過期等等)</ol>
	</font></div>

	<li>既然 ssh 是比較安全的資料封包傳送方式，那麼我就可以在 Internet 上面開放我的
	Linux 主機的 SSH 服務了嗎？！請說明您選擇的答案的原因！</li>
	<div class=block2><font color=white size=-1>
	最好不要對 Internet 開放您的 SSH 服務，因為 SSH 的加密函式庫使用的是 openssl ，一般 Linux distribution 使用的 
	SSH 則是 openssh ，這兩個套件事實上仍有不少的漏洞被發佈過，因此，最好不要對 Internet 開放，畢竟 
	SSH 對於主機的使用權限是很高的！ 
	</font></div>

	<li>如果我想要將 server 的重要資料備份到 backserver，如果可以使用 rsync 透過 ssh 的通道，
	你可以請嘗試這樣做：<ol><li>先在 server 上面以 root 建置 ssh 的 public 與 private key pair ；
	<li>將 public key 傳送與設定到 backserver 上的某個使用者環境下；
	<li>在 backserver 上面製作好預計要存放備份資料的目錄！重點在於『權限』的設定上！
	<li>在 server 上面設定好 rsync 的備份 script ～
	<li>利用 crontab 每隔一段時間自動異地備份。</ol>
	請依照上述的作法在您的兩部主機上面進行測試與實作。(未提供解答)</li>
</ul>
</div>


<hr /><a NAME="reference"></a><img src="/images/penguin-m.gif" alt="大標題的圖示" height="34" width="25" align="middle" /><span class="text_h1">參考資源</span><br />
<div class=block1>
<ul>
	<li>OpenSSH 官方網站：<a href="http://www.openssh.com/" target="_blank">http://www.openssh.com/</a></li>
	<li>OpenSSL 官方網站：<a href="http://www.openssl.org/" target="_blank">http://www.openssl.org/</a></li>
	<li>putty 官方網站：<a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/" 
		target="_blank">http://www.chiark.greenend.org.uk/~sgtatham/putty/</a></li>
	<li>pputty 中文網站：<a href="http://www.csie.ntu.edu.tw/~piaip/prjs/pputty/" 
		target="_blank">http://www.csie.ntu.edu.tw/~piaip/prjs/pputty/</a></li>
	<li>man vncserver</li>
	<li>man Xvnc</li>
	<li>使用 X 的 VNC Module：<a href="http://phorum.study-area.org/viewtopic.htm?t=25713"
		target="_blank">http://phorum.study-area.org/viewtopic.htm?t=25713</a></li>
	<li><a href="http://fedoranews.org/tchung/vnc/03.shtml" 
		target="_blank">http://fedoranews.org/tchung/vnc/03.shtml</a></li>
	<li><a href="http://www.faqs.org/docs/Linux-HOWTO/XDMCP-HOWTO.html" 
		target="_blank">http://www.faqs.org/docs/Linux-HOWTO/XDMCP-HOWTO.html</a></li>
	<li>man rsh</li>
	<li>man rlogin</li>
	<li>酷學園：用 rsync 做備份：<a href="http://phorum.study-area.org/viewtopic.htm?t=15553"
		target="_blank">http://phorum.study-area.org/viewtopic.htm?t=15553</a></li>
	<li>臥龍小三的 rsync 介紹：<a href="http://linux.tnc.edu.tw/techdoc/rsync.htm"
		target="_blank">http://linux.tnc.edu.tw/techdoc/rsync.htm</a></li>
	<li>ADJ 實驗室的 rsync + SSH：<a href="http://www.adj.idv.tw/server/linux_rsync.htm"
		target="_blank">http://www.adj.idv.tw/server/linux_rsync.htm</a></li>
</ul>
</div>


<hr /><span class=text_history>
2002/11/14：第一次完成<br />
2003/03/08：加入標頭說明，與修改部分內容，例如 Telnet 伺服器軟體的安裝等等，以及 SSH 的 putty 使用中文狀態！<br />
2003/09/09：將本文進行一些修訂，此外，加入了課後練習！<br />
2005/07/02：將舊的文章移動到 <a href="0310telnetssh/0310telnetssh.htm">這裡</a> 。<br />
2005/07/07：好不容易將 VNC 還有 XDMCP 給他寫了寫～大家幫鳥哥參考看看啊～<br />
2005/07/09：加入了讓 VNC 與 tty7 同步的 vnc.so 模組的說明<br />
2005/11/22：加入了 <a href="#rsh">RSH 伺服器</a> 的相關資料！<br />
2006/09/18：將 putty 的介紹轉成 pietty 的介紹！因為 pietty 更好用！另外也將 rsh 重新改寫一下，校稿過！<br />
2006/09/19：加入 rsync 的簡易說明與操作！最文末的習題可以瞧一瞧！<br />
hint: 可以加入 RDP，那個 Windows 的遠端桌面系統。<br />
</span>
<hr /><span class="text_date">2002/11/14以來統計人數</span><br />
<img SRC="http://linux.vbird.org/cgi-bin/Count.cgi?dd=A&ft=0&sh=T&pad=Y&df=vbird_linux_server_0310telnetssh.dat" 
	NOSAVE height=15 width=60 align=ABSCENTER><br />
    
</td>
  <td style="width:16px; font-size:6px;
	background-image:url('/images/border-middle-right.jpg')">　</td></tr>
<tr><td style="width:16px; height:16px; background-image:url('/images/border-bottom-left.jpg');
        font-size:6px">　</td>
    <td style="width:750px; height:16px; font-size:6px;
        background-image:url('/images/border-bottom-center.jpg')">　</td>

    <td style="width:16px; height:16px; background-image:url('/images/border-bottom-right.jpg');
        font-size:6px">　</td></tr>
</table>

<div style="padding-top:10px; text-align:center">
<span style="font-size: 80%">

	本網頁主要以 <a href="http://moztw.org" target="_blank">firefox</a> 配合解析度 1024x768 作為設計依據<br />
	<a href="http://linux.vbird.org" target="_top" title="前往鳥哥的首頁">http://linux.vbird.org</a>
	is designed by <a href="mailto:vbird@mail.vbird.idv.tw" title="聯絡鳥哥(我不要廣告信！)">VBird</a>
		during 2001-2009.
	<a href="http://aerosol.ev.ncku.edu.tw">Aerosol Lab.</a></span>

</div>
</center>
</body>
</html>
